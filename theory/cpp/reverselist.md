# é“¾è¡¨

âŒšï¸:2020å¹´11æœˆ30æ—¥

ğŸ“šå‚è€ƒ

---



## 1. åè½¬é“¾è¡¨

é¢˜ç›®ï¼šè¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œåè½¬é“¾è¡¨åï¼Œè¾“å‡ºæ–°é“¾è¡¨çš„è¡¨å¤´

ç¤ºä¾‹1

è¾“å…¥

```
{1,2,3}
```

è¿”å›å€¼

```
{3,2,1}
```



### æ–¹æ³•ä¸€ï¼šæ„é€ é“¾è¡¨

å¦‚æœæ­¤ç±»å‹çš„é¢˜å‡ºç°åœ¨ç¬”è¯•ä¸­ï¼Œå¦‚æœå†…å­˜è¦æ±‚ä¸é«˜ï¼Œå¯ä»¥é‡‡ç”¨å¦‚ä¸‹æ–¹æ³•ï¼š
å¯ä»¥å…ˆç”¨ä¸€ä¸ªvectorå°†å•é“¾è¡¨çš„æŒ‡é’ˆéƒ½å­˜èµ·æ¥ï¼Œç„¶åå†æ„é€ é“¾è¡¨ã€‚
æ­¤æ–¹æ³•ç®€å•æ˜“æ‡‚ï¼Œä»£ç å¥½äº›ã€‚

**ä»£ç ï¼š**

```
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if (!pHead) return nullptr;
        vector<ListNode*> v;
        while (pHead) {
            v.push_back(pHead);
            pHead = pHead->next;
        }
        reverse(v.begin(), v.end()); // åè½¬vectorï¼Œä¹Ÿå¯ä»¥é€†å‘éå†
        ListNode *head = v[0];
        ListNode *cur = head;
        for (int i=1; i<v.size(); ++i) { // æ„é€ é“¾è¡¨
            cur->next = v[i]; // å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            cur = cur->next; // å½“å‰èŠ‚ç‚¹åç§»
        }
        cur->next = nullptr; // åˆ‡è®°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘nullptr
        return head;
    }
};


```

æ—¶é—´å¤æ‚åº¦ï¼šO(n)
ç©ºé—´å¤æ‚åº¦ï¼šO(n), ç”¨äº†ä¸€ä¸ªvectoræ¥å­˜å•é“¾è¡¨

### æ–¹æ³•äºŒï¼šæ­£è§„è§£æ³•

ä½†æ˜¯é¢è¯•çš„æ—¶å€™ï¼Œä¸Šä¸€ç§è§£æ³•å½“ç„¶ä¸è¡Œã€‚æ­¤é¢˜æƒ³è€ƒå¯Ÿçš„æ˜¯ï¼šå¦‚ä½•è°ƒæ•´é“¾è¡¨æŒ‡é’ˆï¼Œæ¥è¾¾åˆ°åè½¬é“¾è¡¨çš„ç›®çš„ã€‚
åˆå§‹åŒ–ï¼š3ä¸ªæŒ‡é’ˆ

1ï¼‰preæŒ‡é’ˆæŒ‡å‘å·²ç»åè½¬å¥½çš„é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¼€å§‹æ²¡æœ‰åè½¬ï¼Œæ‰€ä»¥æŒ‡å‘nullptr

2ï¼‰curæŒ‡é’ˆæŒ‡å‘å¾…åè½¬é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€å¼€å§‹ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¾…åè½¬ï¼Œæ‰€ä»¥æŒ‡å‘head

3ï¼‰nexæŒ‡é’ˆæŒ‡å‘å¾…åè½¬é“¾è¡¨çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œç›®çš„æ˜¯ä¿å­˜é“¾è¡¨ï¼Œå› ä¸ºcuræ”¹å˜æŒ‡å‘åï¼Œåé¢çš„é“¾è¡¨åˆ™å¤±æ•ˆäº†ï¼Œæ‰€ä»¥éœ€è¦ä¿å­˜

æ¥ä¸‹æ¥ï¼Œå¾ªç¯æ‰§è¡Œä»¥ä¸‹ä¸‰ä¸ªæ“ä½œ

1ï¼‰nex = cur->next, ä¿å­˜ä½œç”¨

2ï¼‰cur->next = pre æœªåè½¬é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸ªæŒ‡é’ˆæŒ‡å‘å·²åè½¬é“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹

3ï¼‰pre = curï¼Œ cur = nex; æŒ‡é’ˆåç§»ï¼Œæ“ä½œä¸‹ä¸€ä¸ªæœªåè½¬é“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹

å¾ªç¯æ¡ä»¶ï¼Œå½“ç„¶æ˜¯cur != nullptr

å¾ªç¯ç»“æŸåï¼Œcurå½“ç„¶ä¸ºnullptrï¼Œæ‰€ä»¥è¿”å›preï¼Œå³ä¸ºåè½¬åçš„å¤´ç»“ç‚¹

è¿™é‡Œä»¥1->2->3->4->5 ä¸¾ä¾‹ï¼š

![å›¾ç‰‡è¯´æ˜](imgs/284295_1586789721357_E28402DF0CF9607FDE48415DABE8B14E.png)



![å›¾ç‰‡è¯´æ˜](imgs/284295_1586789770222_32ECB43D8FE9B99E3B1FE4D4D7B4B010.png)









![å›¾ç‰‡è¯´æ˜](imgs/284295_1586789854766_5042B85C914EBCC58062923F222645BD.png)





![å›¾ç‰‡è¯´æ˜](imgs/284295_1586789937254_99B36A7154EFAB15ED8E5C7EA180EC4A.png)



ä¸­é—´éƒ½æ˜¯é‡å¤æ­¥éª¤ï¼Œçœç•¥äº†ã€‚ã€‚ã€‚

------

**ä»£ç **

```
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode *pre = nullptr;
        ListNode *cur = pHead;
        ListNode *nex = nullptr; // è¿™é‡Œå¯ä»¥æŒ‡å‘nullptrï¼Œå¾ªç¯é‡Œé¢è¦é‡æ–°æŒ‡å‘
        while (cur) {
            nex = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nex;
        }
        return pre;
    }
};
```

æ—¶é—´å¤æ‚åº¦ï¼šO(n), éå†ä¸€æ¬¡é“¾è¡¨
ç©ºé—´å¤æ‚åº¦ï¼šO(1)



## 2. ç›¸çˆ±ç›¸æ€å¥½åŸºå‹â€”â€”æ•°ç»„ä¸é“¾è¡¨

**æ— æ³•é«˜æ•ˆè·å–é•¿åº¦ï¼Œæ— æ³•æ ¹æ®åç§»å¿«é€Ÿè®¿é—®å…ƒç´ **ï¼Œæ˜¯é“¾è¡¨çš„ä¸¤ä¸ªåŠ£åŠ¿ã€‚ç„¶è€Œé¢è¯•çš„æ—¶å€™ç»å¸¸ç¢°è§è¯¸å¦‚**è·å–å€’æ•°ç¬¬kä¸ªå…ƒç´ ï¼Œè·å–ä¸­é—´ä½ç½®çš„å…ƒç´ ï¼Œåˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯ï¼Œåˆ¤æ–­ç¯çš„é•¿åº¦ç­‰å’Œé•¿åº¦ä¸ä½ç½®æœ‰å…³**çš„é—®é¢˜ã€‚è¿™äº›é—®é¢˜éƒ½å¯ä»¥é€šè¿‡çµæ´»è¿ç”¨åŒæŒ‡é’ˆæ¥è§£å†³ã€‚



Tipsï¼šåŒæŒ‡é’ˆå¹¶ä¸æ˜¯å›ºå®šçš„å…¬å¼ï¼Œè€Œæ˜¯ä¸€ç§æ€ç»´æ–¹å¼~

### 1. è·å–å€’æ•°ç¬¬kä¸ªå…ƒç´ 

å…ˆæ¥çœ‹"å€’æ•°ç¬¬kä¸ªå…ƒç´ çš„é—®é¢˜"ã€‚è®¾æœ‰ä¸¤ä¸ªæŒ‡é’ˆ p å’Œ qï¼Œåˆå§‹æ—¶å‡æŒ‡å‘å¤´ç»“ç‚¹ã€‚é¦–å…ˆï¼Œå…ˆè®© p æ²¿ç€ next ç§»åŠ¨ k æ¬¡ã€‚æ­¤æ—¶ï¼Œp æŒ‡å‘ç¬¬ k+1ä¸ªç»“ç‚¹ï¼Œq æŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œä¸¤ä¸ªæŒ‡é’ˆçš„è·ç¦»ä¸º k ã€‚ç„¶åï¼ŒåŒæ—¶ç§»åŠ¨ p å’Œ qï¼Œç›´åˆ° p æŒ‡å‘ç©ºï¼Œæ­¤æ—¶ q å³æŒ‡å‘å€’æ•°ç¬¬ k ä¸ªç»“ç‚¹ã€‚å¯ä»¥å‚è€ƒä¸‹å›¾æ¥ç†è§£ï¼š

![](imgs/12.png)

```c
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *p = head, *q = head; //åˆå§‹åŒ–
        while(k--) {   //å°† pæŒ‡é’ˆç§»åŠ¨ k æ¬¡
            p = p->next;
        }
        while(p != nullptr) {//åŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ° p == nullptr
            p = p->next;
            q = q->next;
        }
        return q;
    }
};
```



### 2. è·å–ä¸­é—´å…ƒç´ çš„é—®é¢˜

è·å–ä¸­é—´å…ƒç´ çš„é—®é¢˜ã€‚è®¾æœ‰ä¸¤ä¸ªæŒ‡é’ˆ fast å’Œ slowï¼Œåˆå§‹æ—¶æŒ‡å‘å¤´èŠ‚ç‚¹ã€‚æ¯æ¬¡ç§»åŠ¨æ—¶ï¼Œfastå‘åèµ°ä¸¤æ¬¡ï¼Œslowå‘åèµ°ä¸€æ¬¡ï¼Œç›´åˆ° fast æ— æ³•å‘åèµ°ä¸¤æ¬¡ã€‚è¿™ä½¿å¾—åœ¨æ¯è½®ç§»åŠ¨ä¹‹åã€‚fast å’Œ slow çš„è·ç¦»å°±ä¼šå¢åŠ ä¸€ã€‚è®¾é“¾è¡¨æœ‰ n ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæœ€å¤šç§»åŠ¨ n/2 è½®ã€‚å½“ n ä¸ºå¥‡æ•°æ—¶ï¼Œslow æ°å¥½æŒ‡å‘ä¸­é—´ç»“ç‚¹ï¼Œå½“ n ä¸º å¶æ•°æ—¶ï¼Œslow æ°å¥½æŒ‡å‘ä¸­é—´ä¸¤ä¸ªç»“ç‚¹çš„é å‰ä¸€ä¸ª(å¯ä»¥è€ƒè™‘ä¸‹å¦‚ä½•ä½¿å…¶æŒ‡å‘åä¸€ä¸ªç»“ç‚¹å‘¢ï¼Ÿ)ã€‚



![](imgs/13.png)

ä¸‹è¿°ä»£ç å®ç°äº† n ä¸º**å¶æ•°**æ—¶æ…¢æŒ‡é’ˆæŒ‡å‘**é åç»“ç‚¹**ã€‚

```c
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *p = head, *q = head;
        while(q != nullptr && q->next != nullptr) {
            p = p->next;
            q = q->next->next;
        }
        return p;
    } 
};
```

### 3. åˆ¤æ–­é“¾è¡¨æ˜¯å¦å­˜åœ¨ç¯

æ˜¯å¦å­˜åœ¨ç¯çš„é—®é¢˜ã€‚å¦‚æœå°†å°¾ç»“ç‚¹çš„ next æŒ‡é’ˆæŒ‡å‘å…¶ä»–ä»»æ„ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆé“¾è¡¨å°±å­˜åœ¨äº†ä¸€ä¸ªç¯ã€‚

![](imgs/14.png)

ä¸Šä¸€éƒ¨åˆ†ä¸­ï¼Œæ€»ç»“å¿«æ…¢æŒ‡é’ˆçš„ç‰¹æ€§ â€”â€” æ¯è½®ç§»åŠ¨ä¹‹åä¸¤è€…çš„è·ç¦»ä¼šåŠ ä¸€ã€‚ä¸‹é¢ä¼šç»§ç»­ç”¨è¯¥ç‰¹æ€§è§£å†³ç¯çš„é—®é¢˜ã€‚

å½“ä¸€ä¸ªé“¾è¡¨æœ‰ç¯æ—¶ï¼Œå¿«æ…¢æŒ‡é’ˆéƒ½ä¼šé™·å…¥ç¯ä¸­è¿›è¡Œæ— é™æ¬¡ç§»åŠ¨ï¼Œç„¶åå˜æˆäº†è¿½åŠé—®é¢˜ã€‚æƒ³è±¡ä¸€ä¸‹åœ¨æ“åœºè·‘æ­¥çš„åœºæ™¯ï¼Œåªè¦ä¸€ç›´è·‘ä¸‹å»ï¼Œå¿«çš„æ€»ä¼šè¿½ä¸Šæ…¢çš„ã€‚å½“ä¸¤ä¸ªæŒ‡é’ˆéƒ½è¿›å…¥ç¯åï¼Œæ¯è½®ç§»åŠ¨ä½¿å¾—æ…¢æŒ‡é’ˆåˆ°å¿«æŒ‡é’ˆçš„è·ç¦»å¢åŠ ä¸€ï¼ŒåŒæ—¶å¿«æŒ‡é’ˆåˆ°æ…¢æŒ‡é’ˆçš„è·ç¦»ä¹Ÿå‡å°‘ä¸€ï¼Œåªè¦ä¸€ç›´ç§»åŠ¨ä¸‹å»ï¼Œå¿«æŒ‡é’ˆæ€»ä¼šè¿½ä¸Šæ…¢æŒ‡é’ˆã€‚



![](imgs/15.gif)

æ ¹æ®ä¸Šè¿°è¡¨è¿°å¾—å‡ºï¼Œå¦‚æœä¸€ä¸ªé“¾è¡¨å­˜åœ¨ç¯ï¼Œé‚£ä¹ˆå¿«æ…¢æŒ‡é’ˆå¿…ç„¶ä¼šç›¸é‡ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```c
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != nullptr) {
            fast = fast->next;
            if(fast != nullptr) {
                fast = fast->next;
            }
            if(fast == slow) {
                return true;
            }
            slow = slow->next;
        }
        return nullptr;
    }
};
```

## 3.åˆå¹¶é“¾è¡¨

å°†ä¸¤ä¸ªæœ‰åºçš„é“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°é“¾è¡¨ï¼Œè¦æ±‚æ–°çš„é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ä¸¤ä¸ªé“¾è¡¨çš„èŠ‚ç‚¹æ¥ç”Ÿæˆçš„ï¼Œä¸”åˆå¹¶åæ–°é“¾è¡¨ä¾ç„¶æœ‰åºã€‚

```
ç¤ºä¾‹1
è¾“å…¥

å¤åˆ¶
{1},{2}
è¿”å›å€¼

å¤åˆ¶
{1,2}
ç¤ºä¾‹2
è¾“å…¥

å¤åˆ¶
{2},{1}
è¿”å›å€¼

å¤åˆ¶
{1,2}
```



```c
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param l1 ListNodeç±» 
     * @param l2 ListNodeç±» 
     * @return ListNodeç±»
     */
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1 == nullptr){
            return l2;
        } else if (l2 == nullptr) {
            return l1;
        }
        ListNode* ll1 = l1;
        ListNode* ll2 = l2;
        ListNode* res = nullptr;
        if(ll1->val < ll2->val){
            res = ll1;
            ll1 = ll1->next;
        } else {
            res = ll2;
            ll2 = ll2->next;
        }
        ListNode* head = res;
        while(ll1!=nullptr && ll2 != nullptr){
            if(ll1->val < ll2->val){
                res->next = ll1;
                ll1 = ll1->next;
            } else {
                res->next = ll2;
                ll2 = ll2->next;
            }
            res = res->next;
        }
        if(ll1 != nullptr){
            res->next = ll1;
        } else if (ll2 != nullptr) {
            res->next = ll2;
        }
        return head;
        // write code here
    }
};
```

