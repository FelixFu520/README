# C++11å¹¶å‘ä¸å¤šçº¿ç¨‹

âŒšï¸:2021å¹´10æœˆ28æ—¥

ğŸ“šå‚è€ƒ



---

## 1. å¹¶å‘åŸºæœ¬æ¦‚å¿µåŠå®ç°ï¼Œè¿›ç¨‹ã€çº¿ç¨‹åŸºæœ¬æ¦‚å¿µ

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/fcbdaeb87cd5a8987afd06a2c650e7b9.png)



### **ä¸€ã€å¹¶å‘ã€è¿›ç¨‹ã€çº¿ç¨‹çš„åŸºæœ¬æ¦‚å¿µå’Œç»¼è¿°**

å¹¶å‘ï¼Œçº¿ç¨‹ï¼Œè¿›ç¨‹è¦æ±‚å¿…é¡»æŒæ¡

#### *1.1 å¹¶å‘*

- ä¸¤ä¸ªæˆ–è€…æ›´å¤šçš„ä»»åŠ¡ï¼ˆç‹¬ç«‹çš„æ´»åŠ¨ï¼‰åŒæ—¶å‘ç”Ÿï¼ˆè¿›è¡Œï¼‰ï¼šä¸€ä¸ªç¨‹åºåŒæ—¶æ‰§è¡Œå¤šä¸ªç‹¬ç«‹çš„ä»»åŠ¡ï¼›
- ä»¥å¾€è®¡ç®—æœºï¼Œå•æ ¸cpuï¼ˆä¸­å¤®å¤„ç†å™¨ï¼‰ï¼šæŸä¸€ä¸ªæ—¶åˆ»åªèƒ½æ‰§è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œç”±æ“ä½œç³»ç»Ÿè°ƒåº¦ï¼Œæ¯ç§’é’Ÿè¿›è¡Œå¤šæ¬¡æ‰€è°“çš„â€œä»»åŠ¡åˆ‡æ¢â€ã€‚å¹¶å‘çš„å‡è±¡ï¼ˆä¸æ˜¯çœŸæ­£çš„å¹¶å‘ï¼‰ï¼Œåˆ‡æ¢ï¼ˆä¸Šä¸‹æ–‡åˆ‡æ¢ï¼‰æ—¶è¦ä¿å­˜å˜é‡çš„çŠ¶æ€ã€æ‰§è¡Œè¿›åº¦ç­‰ï¼Œå­˜åœ¨æ—¶é—´å¼€é”€ï¼›
- éšç€ç¡¬ä»¶å‘å±•ï¼Œå‡ºç°äº†å¤šå¤„ç†å™¨è®¡ç®—æœºï¼šç”¨äºæœåŠ¡å™¨å’Œé«˜æ€§èƒ½è®¡ç®—é¢†åŸŸã€‚å°å¼æœºï¼šåœ¨ä¸€å—èŠ¯ç‰‡ä¸Šæœ‰å¤šæ ¸ï¼ˆä¸€ä¸ªCPUå†…æœ‰å¤šä¸ªè¿ç®—æ ¸å¿ƒï¼Œå¯¹äºæ“ä½œç³»ç»Ÿæ¥è¯´ï¼Œæ¯ä¸ªæ ¸å¿ƒéƒ½æ˜¯ä½œä¸ºå•ç‹¬çš„CPUå¯¹å¾…çš„ï¼‰ï¼šåŒæ ¸ï¼Œ4æ ¸ï¼Œ8æ ¸ï¼Œ10æ ¸ï¼ˆè‡ªå·±çš„ç¬”è®°æœ¬æ˜¯4æ ¸8çº¿ç¨‹çš„ï¼‰ã€‚èƒ½å¤Ÿå®ç°çœŸæ­£çš„å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»»åŠ¡ï¼ˆç¡¬ä»¶å¹¶å‘ï¼‰
- ä½¿ç”¨å¹¶å‘çš„åŸå› ï¼šä¸»è¦å°±æ˜¯åŒæ—¶å¯ä»¥å¹²å¤šä¸ªäº‹ï¼Œæé«˜æ€§èƒ½

#### *1.2 å¯æ‰§è¡Œç¨‹åº*

- ç£ç›˜ä¸Šçš„ä¸€ä¸ªæ–‡ä»¶ï¼Œwindowsä¸‹ï¼Œæ‰©å±•åä¸º.exeï¼›linuxä¸‹ï¼Œls -laï¼Œrwxï¼ˆå¯è¯»å¯å†™å¯æ‰§è¡Œï¼‰

#### *1.3 è¿›ç¨‹*

- è¿è¡Œä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºï¼Œåœ¨windowsä¸‹ï¼Œå¯åŒå‡»ï¼›åœ¨linuxä¸‹ï¼Œ./æ–‡ä»¶å
- è¿›è¡Œï¼Œä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºè¿è¡Œèµ·æ¥äº†ï¼Œå°±å«åˆ›å»ºäº†ä¸€ä¸ªè¿›ç¨‹ã€‚è¿›ç¨‹å°±æ˜¯è¿è¡Œèµ·æ¥çš„å¯æ‰§è¡Œç¨‹åºã€‚

#### *1.4 çº¿ç¨‹*

â‘ 

- a)æ¯ä¸ªè¿›ç¨‹ï¼ˆæ‰§è¡Œèµ·æ¥çš„å¯æ‰§è¡Œç¨‹åºï¼‰ï¼Œéƒ½æœ‰å”¯ä¸€çš„ä¸€ä¸ªä¸»çº¿ç¨‹
- b)å½“æ‰§è¡Œå¯æ‰§è¡Œç¨‹åºæ—¶ï¼Œäº§ç”Ÿä¸€ä¸ªè¿›ç¨‹åï¼Œè¿™ä¸ªä¸»çº¿ç¨‹å°±éšç€è¿™ä¸ªè¿›ç¨‹é»˜é»˜å¯åŠ¨èµ·æ¥äº†
- ctrl+F5è¿è¡Œè¿™ä¸ªç¨‹åºçš„æ—¶å€™ï¼Œå®é™…ä¸Šæ˜¯è¿›ç¨‹çš„ä¸»çº¿ç¨‹æ¥æ‰§è¡Œï¼ˆè°ƒç”¨ï¼‰è¿™ä¸ªmainå‡½æ•°ä¸­çš„ä»£ç 
- çº¿ç¨‹ï¼šç”¨æ¥æ‰§è¡Œä»£ç çš„ã€‚çº¿ç¨‹è¿™ä¸ªä¸œè¥¿ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€æ¡ä»£ç çš„æ‰§è¡Œé€šè·¯

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/9611dcda1161259c8508deac6e5f5815.png)

â‘¡

- é™¤äº†ä¸»çº¿ç¨‹ä¹‹å¤–ï¼Œå¯ä»¥é€šè¿‡å†™ä»£ç æ¥åˆ›å»ºå…¶ä»–çº¿ç¨‹ï¼Œå…¶ä»–çº¿ç¨‹èµ°çš„æ˜¯åˆ«çš„é“è·¯ï¼Œç”šè‡³åŒºä¸åŒçš„åœ°æ–¹
- æ¯åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œå°±å¯ä»¥åœ¨åŒä¸€æ—¶åˆ»ï¼Œå¤šå¹²ä¸€ä¸ªä¸åŒçš„äº‹ï¼ˆå¤šèµ°ä¸€æ¡ä¸åŒçš„ä»£ç æ‰§è¡Œè·¯å¾„ï¼‰

â‘¢

- å¤šçº¿ç¨‹ï¼ˆå¹¶å‘ï¼‰
- çº¿ç¨‹å¹¶ä¸æ˜¯è¶Šå¤šè¶Šå¥½ï¼Œæ¯ä¸ªçº¿ç¨‹ï¼Œéƒ½éœ€è¦ä¸€ä¸ªç‹¬ç«‹çš„å †æ ˆç©ºé—´ï¼ˆå¤§çº¦1Mï¼‰ï¼Œçº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢è¦ä¿å­˜å¾ˆå¤šä¸­é—´çŠ¶æ€ï¼Œåˆ‡æ¢ä¹Ÿä¼šè€—è´¹æœ¬è¯¥å±äºç¨‹åºè¿è¡Œçš„æ—¶é—´

å¿…é¡»ä½¿ç”¨å¤šçº¿ç¨‹çš„æ¡ˆä¾‹
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/8a65d890edc53b34a5b95987946d0d09.png)
![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/6dd7da124b3267383e582cbc95194934.png)

#### *1.5 å­¦ä¹ å¿ƒå¾—*

- å¼€å‘å¤šçº¿ç¨‹ç¨‹åºï¼šä¸€ä¸ªæ˜¯å®åŠ›çš„ä½“ç°ï¼Œä¸€ä¸ªæ˜¯å•†ç”¨çš„å¿…é¡»éœ€æ±‚
- çº¿ç¨‹å¼€å‘æœ‰ä¸€å®šéš¾åº¦
- C++çº¿ç¨‹ä¼šè®¾è®¡å¾ˆå¤šæ–°æ¦‚å¿µ
- ç½‘ç»œæ–¹å‘ï¼šç½‘ç»œé€šè®¯ã€ç½‘ç»œæœåŠ¡å™¨ï¼Œå¤šçº¿ç¨‹æ˜¯ç»å¯¹ç»•ä¸å¼€çš„

### **äºŒã€å¹¶å‘çš„å®ç°æ–¹æ³•**

å®ç°å¹¶å‘çš„æ‰‹æ®µï¼š
aï¼‰é€šè¿‡å¤šä¸ªè¿›ç¨‹å®ç°å¹¶å‘
bï¼‰åœ¨å•ç‹¬çš„è¿›ç¨‹ä¸­ï¼Œå†™ä»£ç åˆ›å»ºé™¤äº†ä¸»çº¿ç¨‹ä¹‹å¤–çš„å…¶ä»–çº¿ç¨‹æ¥å®ç°å¹¶å‘

#### *2.1 å¤šè¿›ç¨‹å¹¶å‘*

- æ¯”å¦‚è´¦å·æœåŠ¡å™¨ä¸€ä¸ªè¿›ç¨‹ï¼Œæ¸¸æˆæœåŠ¡å™¨ä¸€ä¸ªè¿›ç¨‹ã€‚
- æœåŠ¡å™¨è¿›ç¨‹ä¹‹é—´å­˜åœ¨é€šä¿¡ï¼ˆåŒä¸€ä¸ªç”µè„‘ä¸Šï¼šç®¡é“ï¼Œæ–‡ä»¶ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ï¼Œå…±äº«å†…å­˜ï¼‰ï¼›ï¼ˆä¸åŒç”µè„‘ä¸Šï¼šsocketé€šä¿¡æŠ€æœ¯ï¼‰

#### *2.2 å¤šçº¿ç¨‹å¹¶å‘*

- çº¿ç¨‹ï¼šæ„Ÿè§‰åƒæ˜¯è½»é‡çº§çš„è¿›ç¨‹ã€‚æ¯ä¸ªè¿›ç¨‹æœ‰è‡ªå·±ç‹¬ç«‹çš„è¿è¡Œè·¯å¾„ï¼Œä½†ä¸€ä¸ªè¿›ç¨‹ä¸­çš„æ‰€æœ‰çº¿ç¨‹å…±äº«åœ°å€ç©ºé—´ï¼ˆå…±äº«å†…å­˜ï¼‰ï¼Œå…¨å±€å˜é‡ã€å…¨å±€å†…å­˜ã€å…¨å±€å¼•ç”¨éƒ½å¯ä»¥åœ¨çº¿ç¨‹ä¹‹é—´ä¼ é€’ï¼Œæ‰€ä»¥å¤šçº¿ç¨‹å¼€é”€è¿œè¿œå°äºå¤šè¿›ç¨‹
- å¤šè¿›ç¨‹å¹¶å‘æ ¸å¤šçº¿ç¨‹å¹¶å‘å¯ä»¥æ··åˆä½¿ç”¨ï¼Œä½†å»ºè®®ä¼˜å…ˆè€ƒè™‘å¤šçº¿ç¨‹æŠ€æœ¯
- æœ¬è¯¾ç¨‹ä¸­åªè®²å¤šçº¿ç¨‹å¹¶å‘æŠ€æœ¯

### **ä¸‰ã€C++11æ–°æ ‡å‡†çº¿ç¨‹åº“**

#### *ä»¥å¾€*

- windowsï¼šCreateThread(), _beginthread(),_beginthreadexe()åˆ›å»ºçº¿ç¨‹ï¼›linuxï¼špthread_create()åˆ›å»ºçº¿ç¨‹ï¼›ä¸èƒ½è·¨å¹³å°
- ä¸´ç•ŒåŒºï¼Œäº’æ–¥é‡
- POSIX thread(pthread):è·¨å¹³å°ï¼Œä½†è¦åšä¸€ç•ªé…ç½®ï¼Œä¹Ÿä¸æ–¹ä¾¿

#### *C++11*

- ä»C++11æ–°æ ‡å‡†ï¼ŒC++è¯­è¨€æœ¬èº«å¢åŠ å¯¹å¤šçº¿ç¨‹çš„æ”¯æŒï¼Œæ„å‘³ç€å¯ç§»æ¤æ€§ï¼ˆè·¨å¹³å°ï¼‰ï¼Œè¿™å¤§å¤§å‡å°‘å¼€å‘äººå‘˜çš„å·¥ä½œé‡

## 2. çº¿ç¨‹å¯åŠ¨ã€ç»“æŸï¼Œåˆ›å»ºçº¿ç¨‹å¤šæ³•ã€joinï¼Œdetach

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/asdfasdfasdfasdf)

### **ä¸€ã€èŒƒä¾‹æ¼”ç¤ºçº¿ç¨‹è¿è¡Œçš„å¼€å§‹**

- ç¨‹åºè¿è¡Œèµ·æ¥ï¼Œç”Ÿæˆä¸€ä¸ªè¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹æ‰€å±çš„ä¸»çº¿ç¨‹å¼€å§‹è‡ªåŠ¨è¿è¡Œï¼›å½“ä¸»çº¿ç¨‹ä»mainï¼ˆï¼‰å‡½æ•°è¿”å›ï¼Œåˆ™æ•´ä¸ªè¿›ç¨‹æ‰§è¡Œå®Œæ¯•
- ä¸»çº¿ç¨‹ä»mainï¼ˆï¼‰å¼€å§‹æ‰§è¡Œï¼Œé‚£ä¹ˆæˆ‘ä»¬è‡ªå·±åˆ›å»ºçš„çº¿ç¨‹ï¼Œä¹Ÿéœ€è¦ä»ä¸€ä¸ªå‡½æ•°å¼€å§‹è¿è¡Œï¼ˆåˆå§‹å‡½æ•°ï¼‰ï¼Œä¸€æ—¦è¿™ä¸ªå‡½æ•°è¿è¡Œå®Œæ¯•ï¼Œçº¿ç¨‹ä¹Ÿç»“æŸè¿è¡Œ
- æ•´ä¸ªè¿›ç¨‹æ˜¯å¦æ‰§è¡Œå®Œæ¯•çš„æ ‡å¿—æ˜¯ï¼šä¸»çº¿ç¨‹æ˜¯å¦æ‰§è¡Œå®Œï¼Œå¦‚æœä¸»çº¿ç¨‹æ‰§è¡Œå®Œæ¯•äº†ï¼Œå°±ä»£è¡¨æ•´ä¸ªè¿›ç¨‹æ‰§è¡Œå®Œæ¯•äº†ï¼Œæ­¤æ—¶å¦‚æœå…¶ä»–å­çº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œï¼Œä¹Ÿä¼šè¢«å¼ºè¡Œç»ˆæ­¢ã€æ­¤æ¡æœ‰ä¾‹å¤–ï¼Œä»¥åä¼šè§£é‡Šã€‘



åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼š

- åŒ…å«å¤´æ–‡ä»¶thread
- å†™åˆå§‹å‡½æ•°
- åœ¨mainä¸­åˆ›å»ºthread



å¿…é¡»è¦æ˜ç™½ï¼šæœ‰ä¸¤ä¸ªçº¿ç¨‹åœ¨è·‘ï¼Œç›¸å½“äºæ•´ä¸ªç¨‹åºä¸­æœ‰ä¸¤æ¡çº¿åœ¨åŒæ—¶èµ°ï¼Œå³ä½¿ä¸€æ¡è¢«é˜»å¡ï¼Œå¦ä¸€æ¡ä¹Ÿèƒ½è¿è¡Œ

	#include <iostream>
	#include <thread>
	using namespace std;
	
	void myPrint()
	{
		cout << "æˆ‘çš„çº¿ç¨‹å¼€å§‹è¿è¡Œ" << endl;
		//-------------
		//-------------
		cout << "æˆ‘çš„çº¿ç¨‹è¿è¡Œå®Œæ¯•" << endl;
		return;
	}
	
	int main()
	{
		//(1)åˆ›å»ºäº†çº¿ç¨‹ï¼Œçº¿ç¨‹æ‰§è¡Œèµ·ç‚¹ï¼ˆå…¥å£ï¼‰æ˜¯myPrintï¼›(2)æ‰§è¡Œçº¿ç¨‹
		thread myThread(myPrint);
	    //(2)é˜»å¡ä¸»çº¿ç¨‹å¹¶ç­‰å¾…myPrintæ‰§è¡Œå®Œï¼Œå½“myPrintæ‰§è¡Œå®Œæ¯•ï¼Œjoin()å°±æ‰§è¡Œå®Œæ¯•ï¼Œä¸»çº¿ç¨‹ç»§ç»­å¾€ä¸‹æ‰§è¡Œ
	    //joinæ„ä¸ºæ±‡åˆï¼Œå­çº¿ç¨‹å’Œä¸»çº¿ç¨‹å›åˆ. é˜»å¡ä¸»çº¿ç¨‹ï¼Œè®©ä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹
	    myThread.join();
	
	    //è®¾ç½®æ–­ç‚¹å¯çœ‹åˆ°ä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹çš„è¿‡ç¨‹
	    //F11é€è¯­å¥ï¼Œå°±æ˜¯æ¯æ¬¡æ‰§è¡Œä¸€è¡Œè¯­å¥ï¼Œå¦‚æœç¢°åˆ°å‡½æ•°è°ƒç”¨ï¼Œå®ƒå°±ä¼šè¿›å…¥åˆ°å‡½æ•°é‡Œé¢
	    //F10é€è¿‡ç¨‹ï¼Œç¢°åˆ°å‡½æ•°æ—¶ï¼Œä¸è¿›å…¥å‡½æ•°ï¼ŒæŠŠå‡½æ•°è°ƒç”¨å½“æˆä¸€æ¡è¯­å¥æ‰§è¡Œ
	
	    //(3)ä¼ ç»Ÿå¤šçº¿ç¨‹ç¨‹åºä¸­ï¼Œä¸»çº¿ç¨‹è¦ç­‰å¾…å­çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œç„¶åè‡ªå·±æ‰èƒ½å‘ä¸‹æ‰§è¡Œ
	    //detach:åˆ†ç¦»ï¼Œä¸»çº¿ç¨‹ä¸å†ä¸å­çº¿ç¨‹æ±‡åˆï¼Œä¸å†ç­‰å¾…å­çº¿ç¨‹
	    //detachåï¼Œå­çº¿ç¨‹å’Œä¸»çº¿ç¨‹å¤±å»å…³è”ï¼Œé©»ç•™åœ¨åå°ï¼Œç”±C++è¿è¡Œæ—¶åº“æ¥ç®¡
	    //myThread.detach();
	    // ä¸ºä»€ä¹ˆå¼•å…¥detach():æˆ‘ä»¬åˆ›å»ºäº†å¾ˆå¤šå­çº¿ç¨‹ï¼Œè®©ä¸»çº¿ç¨‹é€ä¸ªç­‰å¾…å­çº¿ç¨‹ï¼Œè¿™ç§æ ‡ç§°æ–¹æ³•ä¸å¤ªå¥½ï¼Œæ‰€ä»¥å¼•å…¥äº†detachã€‚ä½†æ˜¯æœ€å¥½è¿˜è¦joinã€‚
	
	    //(4)joinable()åˆ¤æ–­æ˜¯å¦å¯ä»¥æˆåŠŸä½¿ç”¨join()æˆ–è€…detach()
	    //å¦‚æœè¿”å›trueï¼Œè¯æ˜å¯ä»¥è°ƒç”¨join()æˆ–è€…detach()
	    //å¦‚æœè¿”å›falseï¼Œè¯æ˜è°ƒç”¨è¿‡join()æˆ–è€…detach()ï¼Œjoin()å’Œdetach()éƒ½ä¸èƒ½å†è°ƒç”¨äº†
	    if (myThread.joinable())
	    {
	        cout << "å¯ä»¥è°ƒç”¨å¯ä»¥è°ƒç”¨join()æˆ–è€…detach()" << endl;
	    }
	    else
	    {
	        cout << "ä¸èƒ½è°ƒç”¨å¯ä»¥è°ƒç”¨join()æˆ–è€…detach()" << endl;
	    }
	
	    cout << "Hello World!" << endl;
	    return 0;
	}



é‡è¦è¡¥å……ï¼š

çº¿ç¨‹ç±»å‚æ•°æ˜¯ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ã€‚

ä¸€ç»„å¯æ‰§è¡Œçš„è¯­å¥ç§°ä¸ºå¯è°ƒç”¨å¯¹è±¡ï¼Œc++ä¸­çš„å¯è°ƒç”¨å¯¹è±¡å¯ä»¥æ˜¯å‡½æ•°ã€å‡½æ•°æŒ‡é’ˆã€lambdaè¡¨è¾¾å¼ã€bindåˆ›å»ºçš„å¯¹è±¡æˆ–è€…é‡è½½äº†å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦çš„ç±»å¯¹è±¡ã€‚

### äºŒã€å…¶ä»–åˆ›å»ºçº¿ç¨‹çš„æ–¹æ³•

â‘ åˆ›å»ºä¸€ä¸ªç±»ï¼Œå¹¶ç¼–å†™åœ†æ‹¬å·é‡è½½å‡½æ•°ï¼Œåˆå§‹åŒ–ä¸€ä¸ªè¯¥ç±»çš„å¯¹è±¡ï¼ŒæŠŠè¯¥å¯¹è±¡ä½œä¸ºçº¿ç¨‹å…¥å£åœ°å€

```
class Ta
{
public:
	void operator()() //ä¸èƒ½å¸¦å‚æ•°
	{
		cout << "æˆ‘çš„çº¿ç¨‹å¼€å§‹è¿è¡Œ" << endl;
		//-------------
		//-------------
		cout << "æˆ‘çš„çº¿ç¨‹è¿è¡Œå®Œæ¯•" << endl;
	}
};

//mainå‡½æ•°é‡Œçš„ï¼š
	Ta ta;
	thread myThread(ta);
	myThread.join();
```



â‘¡lambdaè¡¨è¾¾å¼åˆ›å»ºçº¿ç¨‹

```
//mainå‡½æ•°ä¸­
auto lambdaThread = [] {
		cout << "æˆ‘çš„çº¿ç¨‹å¼€å§‹æ‰§è¡Œäº†" << endl;
		//-------------
		//-------------
		cout << "æˆ‘çš„çº¿ç¨‹å¼€å§‹æ‰§è¡Œäº†" << endl;
	};

	thread myThread(lambdaThread);
	myThread.join();

```

â‘¢æŠŠæŸä¸ªç±»ä¸­çš„æŸä¸ªå‡½æ•°ä½œä¸ºçº¿ç¨‹çš„å…¥å£åœ°å€

```
class Data_
{
public:
    void GetMsg(){}
    void SaveMsh(){}
};
//mainå‡½æ•°é‡Œ
    Data_ s;
    //ç¬¬ä¸€ä¸ª&æ„æ€æ˜¯å–å€ï¼Œç¬¬äºŒä¸ª&æ„æ€æ˜¯å¼•ç”¨ï¼Œç›¸å½“äºstd::ref(s)
    //thread oneobj(&Data_::SaveMsh,s)ä¼ å€¼ä¹Ÿæ˜¯å¯ä»¥çš„
    //åœ¨å…¶ä»–çš„æ„é€ å‡½æ•°ä¸­&objæ˜¯ä¸ä¼šä»£è¡¨å¼•ç”¨çš„ï¼Œä¼šè¢«å½“æˆå–åœ°å€
    //è°ƒç”¨æ–¹å¼ï¼šå¯¹è±¡æˆå‘˜å‡½æ•°åœ°å€ï¼Œç±»å®ä¾‹ï¼Œ[æˆå‘˜å‡½æ•°å‚æ•°]
	//ç¬¬äºŒä¸ªå‚æ•°å¯ä»¥ä¼ é€’å¯¹è±¡sï¼Œä¹Ÿå¯ä»¥ä¼ é€’å¼•ç”¨std::ref(s)æˆ–&s
	//ä¼ é€’sï¼Œä¼šè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°åœ¨å­çº¿ç¨‹ä¸­ç”Ÿæˆä¸€ä¸ªæ–°çš„å¯¹è±¡
	//ä¼ é€’&ï¼Œå­çº¿ç¨‹ä¸­è¿˜æ˜¯ç”¨çš„åŸæ¥çš„å¯¹è±¡ï¼Œæ‰€ä»¥å°±ä¸èƒ½detachï¼Œå› ä¸ºä¸»çº¿ç¨‹è¿è¡Œå®Œæ¯•ä¼šæŠŠè¯¥å¯¹è±¡é‡Šæ”¾æ‰
    thread oneobj(&Data_::SaveMsh,&s);
    thread twoobj(&Data_::GetMsg,&s);
    oneobj.join();
    twoobj.join();

```

##  3. çº¿ç¨‹ä¼ å‚è¯¦è§£ï¼Œdetach()å¤§å‘ï¼Œæˆå‘˜å‡½æ•°åšçº¿ç¨‹å‡½æ•°

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/hgsf.png)

### **ä¸€ã€ä¼ é€’ä¸´æ—¶å¯¹è±¡ä½œä¸ºçº¿ç¨‹å‚æ•°**

#### *1.1è¦é¿å…çš„é™·é˜±1ï¼š*

```
#include <iostream>
#include <thread>
using namespace std;

void myPrint(const int &i, char* pmybuf)
{
	//å¦‚æœçº¿ç¨‹ä»ä¸»çº¿ç¨‹detachäº†
	//iä¸æ˜¯mvarçœŸæ­£çš„å¼•ç”¨ï¼Œå®é™…ä¸Šå€¼ä¼ é€’ï¼Œå³ä½¿ä¸»çº¿ç¨‹è¿è¡Œå®Œæ¯•äº†ï¼Œå­çº¿ç¨‹ç”¨iä»ç„¶æ˜¯å®‰å…¨çš„ï¼Œä½†ä»ä¸æ¨èä¼ é€’å¼•ç”¨
	//æ¨èæ”¹ä¸ºconst int i
	cout << i << endl;
	//pmybufè¿˜æ˜¯æŒ‡å‘åŸæ¥çš„å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥è¿™ä¹ˆå†™æ˜¯ä¸å®‰å…¨çš„
	cout << pmybuf << endl;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a test";
	thread myThread(myPrint, mvar, mybuf);//ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å‡½æ•°åï¼Œåä¸¤ä¸ªå‚æ•°æ˜¯å‡½æ•°çš„å‚æ•°
	myThread.join();
	//myThread.detach();
	
	cout << "Hello World!" << endl;
}

```

debugæ—¶å¯ä»¥æŸ¥çœ‹åœ°å€ï¼Œè§‚å¯Ÿä¸¤ä¸ªé‡æ˜¯å¦æ—¶åŒä¸€ä¸ªã€‚

#### *1.2è¦é¿å…çš„é™·é˜±2ï¼š*

```
#include <iostream>
#include <thread>
#include <string>
using namespace std;

void myPrint(const int i, const string& pmybuf)
{
	cout << i << endl;
	cout << pmybuf << endl;
}

int main()
{
	int mvar = 1;
	int& mvary = mvar;
	char mybuf[] = "this is a test";
	//å¦‚æœdetachäº†ï¼Œè¿™æ ·ä»ç„¶æ˜¯ä¸å®‰å…¨çš„
	//å› ä¸ºå­˜åœ¨ä¸»çº¿ç¨‹è¿è¡Œå®Œäº†ï¼Œmybufè¢«å›æ”¶äº†ï¼Œç³»ç»Ÿé‡‡ç”¨mybuféšå¼ç±»å‹è½¬æ¢æˆstring
	//æ¨èå…ˆåˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡thread myThread(myPrint, mvar, string(mybuf));å°±ç»å¯¹å®‰å…¨äº†ã€‚ã€‚ã€‚ã€‚
	thread myThread(myPrint, mvar, mybuf);
	myThread.join();
	//myThread.detach();

	cout << "Hello World!" << endl;
}

```

#### *1.3æ€»ç»“*

- å¦‚æœä¼ é€’intè¿™ç§ç®€å•ç±»å‹ï¼Œæ¨èä½¿ç”¨å€¼ä¼ é€’ï¼Œä¸è¦ç”¨å¼•ç”¨
- å¦‚æœä¼ é€’ç±»å¯¹è±¡ï¼Œé¿å…ä½¿ç”¨éšå¼ç±»å‹è½¬æ¢ï¼Œå…¨éƒ¨éƒ½æ˜¯åˆ›å»ºçº¿ç¨‹è¿™ä¸€è¡Œå°±åˆ›å»ºå‡ºä¸´æ—¶å¯¹è±¡ï¼Œç„¶ååœ¨å‡½æ•°å‚æ•°é‡Œï¼Œç”¨å¼•ç”¨æ¥æ¥ï¼Œå¦åˆ™è¿˜ä¼šåˆ›å»ºå‡ºä¸€ä¸ªå¯¹è±¡
- ç»ˆæç»“è®ºï¼šå»ºè®®ä¸ä½¿ç”¨detach



> ä½¿ç”¨detachæ—¶ã€‚
>
> ![image-20210928132116570](imgs/image-20210928132116570.png)
>
> å¦‚æœçº¿ç¨‹çš„è°ƒç”¨å‡½æ•°ä¸ç”¨å¼•ç”¨ï¼Œåˆ™ä¼šè°ƒç”¨ä¸‰æ¬¡æ„é€ å‡½æ•°ã€‚ï¼ˆ1æ¬¡æ„é€ ã€2æ¬¡æ‹·è´æ„é€ ï¼‰
>
> ä½¿ç”¨å¼•ç”¨çš„è¯ï¼Œæ„é€ ä½¿ç”¨ä¸¤æ¬¡
>
> ![image-20210928132513291](imgs/image-20210928132513291.png)
>
> 

### äºŒã€ä¸´æ—¶å¯¹è±¡ä½œä¸ºçº¿ç¨‹å‚æ•°ç»§ç»­è®²

#### 2.1çº¿ç¨‹idæ¦‚å¿µ

idæ˜¯ä¸ªæ•°å­—ï¼Œæ¯ä¸ªçº¿ç¨‹ï¼ˆä¸ç®¡æ˜¯ä¸»çº¿ç¨‹è¿˜æ˜¯å­çº¿ç¨‹ï¼‰å®é™…ä¸Šéƒ½å¯¹åº”ç€ä¸€ä¸ªæ•°å­—ï¼Œè€Œä¸”æ¯ä¸ªçº¿ç¨‹å¯¹åº”çš„è¿™ä¸ªæ•°å­—éƒ½ä¸ä¸€æ ·
çº¿ç¨‹idå¯ä»¥ç”¨C++æ ‡å‡†åº“é‡Œçš„å‡½æ•°æ¥è·å–ã€‚std::this_thread::get_id()æ¥è·å–

- ä½¿ç”¨å€¼ä¼ é€’

![image-20210928133024426](imgs/image-20210928133024426.png)

![image-20210928132817559](imgs/image-20210928132817559.png)

åœ¨å­çº¿ç¨‹ä¸­æ„é€ 



- ä½¿ç”¨ä¸´æ—¶é‡

![image-20210928133114534](imgs/image-20210928133114534.png)

![image-20210928133131611](imgs/image-20210928133131611.png)



å¯¹æ¯”

![image-20210928133216185](imgs/image-20210928133216185.png)



### ä¸‰ã€ä¼ é€’ç±»å¯¹è±¡ã€æ™ºèƒ½æŒ‡é’ˆä½œä¸ºçº¿ç¨‹å‚æ•°

#### 3.1

```
#include <iostream>
#include <thread>
using namespace std;

class A {
public:
	mutable int m_i; //m_iå³ä½¿å®åœ¨constä¸­ä¹Ÿå¯ä»¥è¢«ä¿®æ”¹
	A(int i) :m_i(i) {}
};

void myPrint(const A& pmybuf)
{
	pmybuf.m_i = 199;
	cout << "å­çº¿ç¨‹myPrintçš„å‚æ•°åœ°å€æ˜¯" << &pmybuf << "thread = " << std::this_thread::get_id() << endl;
}

int main()
{
	A myObj(10);
	//myPrint(const A& pmybuf)ä¸­å¼•ç”¨ä¸èƒ½å»æ‰ï¼Œå¦‚æœå»æ‰ä¼šå¤šåˆ›å»ºä¸€ä¸ªå¯¹è±¡
	//constä¹Ÿä¸èƒ½å»æ‰ï¼Œå»æ‰ä¼šå‡ºé”™
	//å³ä½¿æ˜¯ä¼ é€’çš„constå¼•ç”¨ï¼Œä½†åœ¨å­çº¿ç¨‹ä¸­è¿˜æ˜¯ä¼šè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°æ„é€ ä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œ
	//æ‰€ä»¥åœ¨å­çº¿ç¨‹ä¸­ä¿®æ”¹m_içš„å€¼ä¸ä¼šå½±å“åˆ°ä¸»çº¿ç¨‹
	//å¦‚æœå¸Œæœ›å­çº¿ç¨‹ä¸­ä¿®æ”¹m_içš„å€¼å½±å“åˆ°ä¸»çº¿ç¨‹ï¼Œå¯ä»¥ç”¨thread myThread(myPrint, std::ref(myObj));
	//è¿™æ ·constå°±æ˜¯çœŸçš„å¼•ç”¨äº†ï¼ŒmyPrintå®šä¹‰ä¸­çš„constå°±å¯ä»¥å»æ‰äº†ï¼Œç±»Aå®šä¹‰ä¸­çš„mutableä¹Ÿå¯ä»¥å»æ‰äº†
	thread myThread(myPrint, myObj);
	myThread.join();
	//myThread.detach();

	cout << "Hello World!" << endl;
}

```

#### 3.2

```
#include <iostream>
#include <thread>
#include <memory>
using namespace std;

void myPrint(unique_ptr<int> ptn)
{
	cout << "thread = " << std::this_thread::get_id() << endl;
}

int main()
{
	unique_ptr<int> up(new int(10));
	//ç‹¬å å¼æŒ‡é’ˆåªèƒ½é€šè¿‡std::move()æ‰å¯ä»¥ä¼ é€’ç»™å¦ä¸€ä¸ªæŒ‡é’ˆ
	//ä¼ é€’åupå°±æŒ‡å‘ç©ºï¼Œæ–°çš„ptnæŒ‡å‘åŸæ¥çš„å†…å­˜
	//æ‰€ä»¥è¿™æ—¶å°±ä¸èƒ½ç”¨detachäº†ï¼Œå› ä¸ºå¦‚æœä¸»çº¿ç¨‹å…ˆæ‰§è¡Œå®Œï¼ŒptnæŒ‡å‘çš„å¯¹è±¡å°±è¢«é‡Šæ”¾äº†
	thread myThread(myPrint, std::move(up));
	myThread.join();
	//myThread.detach();

	return 0;
}
```

### **å››ã€ç”¨æˆå‘˜å‡½æ•°æŒ‡é’ˆåšçº¿ç¨‹å‡½æ•°**

æ”¾åœ¨äº†2.2

## 4. åˆ›å»ºå¤šä¸ªçº¿ç¨‹ã€æ•°æ®å…±äº«é—®é¢˜åˆ†æã€æ¡ˆä¾‹ä»£ç 

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/hgf)

### **ä¸€ã€åˆ›å»ºå’Œç­‰å¾…å¤šä¸ªçº¿ç¨‹**

```
void TextThread()
{
     cout << "æˆ‘æ˜¯çº¿ç¨‹" << this_thread::get_id() << endl;
     /*  â€¦  */
     cout << "çº¿ç¨‹" << this_thread::get_id() << "æ‰§è¡Œç»“æŸ" << endl; 
}
 //mainå‡½æ•°é‡Œ     vector threadagg;
     for (int i = 0; i < 10; ++i)
     {
         threadagg.push_back(thread(TextThread));
     }
     for (int i = 0; i < 10; ++i)
     {
         threadagg[i].join();
     }

```

- æŠŠthreadå¯¹è±¡æ”¾å…¥åˆ°å®¹å™¨ä¸­ç®¡ç†ï¼Œçœ‹èµ·æ¥åƒä¸ªthreadå¯¹è±¡æ•°ç»„ï¼Œå¯¹ä¸€æ¬¡åˆ›å»ºå¤§é‡çš„çº¿ç¨‹å¹¶å¯¹å¤§é‡çº¿ç¨‹è¿›è¡Œç®¡ç†æœ‰å¥½å¤„
- å¤šä¸ªçº¿ç¨‹æ‰§è¡Œé¡ºåºæ˜¯ä¹±çš„ï¼Œè·Ÿæ“ä½œç³»ç»Ÿå†…éƒ¨å¯¹çº¿ç¨‹çš„è¿è¡Œè°ƒåº¦æœºåˆ¶æœ‰å…³

### **äºŒï¼šæ•°æ®å…±äº«é—®é¢˜åˆ†æ**

*2.1 åªè¯»çš„æ•°æ®*

- æ˜¯å®‰å…¨ç¨³å®šçš„

*2.2 æœ‰è¯»æœ‰å†™*

- è‹¥ä¸åŠ å¤„ç†ï¼Œå°±ä¼šå‡ºé”™
- æœ€ç®€å•çš„é˜²æ­¢å´©æºƒæ–¹æ³•ï¼šè¯»çš„æ—¶å€™ä¸èƒ½å†™ï¼Œå†™çš„æ—¶å€™ä¸èƒ½è¯»ã€‚
- å†™çš„åŠ¨ä½œåˆ†10å°æ­¥ï¼Œç”±äºä»»åŠ¡åˆ‡æ¢ï¼Œå¯¼è‡´å„ç§è¯¡å¼‚çš„äº‹æƒ…å‘ç”Ÿï¼ˆæœ€å¯èƒ½çš„è¿˜æ˜¯å´©æºƒï¼‰

## 5. äº’æ–¥é‡æ¦‚å¿µã€ç”¨æ³•ã€æ­»é”æ¼”ç¤ºåŠè§£å†³è¯¦è§£

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/fff.png)

### ä¸€ã€äº’æ–¥é‡ï¼ˆmutexï¼‰çš„åŸºæœ¬æ¦‚å¿µ

äº’æ–¥é‡å°±æ˜¯ä¸ªç±»å¯¹è±¡ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€æŠŠé”ï¼Œå¤šä¸ªçº¿ç¨‹å°è¯•ç”¨lock()æˆå‘˜å‡½æ•°æ¥åŠ é”ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½é”å®šæˆåŠŸï¼Œå¦‚æœæ²¡æœ‰é”æˆåŠŸï¼Œé‚£ä¹ˆæµç¨‹å°†å¡åœ¨lock()è¿™é‡Œä¸æ–­å°è¯•å»é”å®šã€‚

äº’æ–¥é‡ä½¿ç”¨è¦å°å¿ƒï¼Œä¿æŠ¤æ•°æ®ä¸å¤šä¹Ÿä¸å°‘ï¼Œå°‘äº†è¾¾ä¸åˆ°æ•ˆæœï¼Œå¤šäº†å½±å“æ•ˆç‡ã€‚

### äºŒã€äº’æ–¥é‡çš„ç”¨æ³•

åŒ…å«#include <mutex>å¤´æ–‡ä»¶

##### 2.1 lock()ï¼Œunlock()

æ­¥éª¤ï¼š1.lock()ï¼Œ2.æ“ä½œå…±äº«æ•°æ®ï¼Œ3.unlock()ã€‚

lock()å’Œunlock()è¦æˆå¯¹ä½¿ç”¨

##### 2.2 lock_guardç±»æ¨¡æ¿

lock_guard<mutex> sbguard(myMutex);å–ä»£lock()å’Œunlock()

lock_guardæ„é€ å‡½æ•°æ‰§è¡Œäº†mutex::lock();

åœ¨ä½œç”¨åŸŸç»“æŸæ—¶ï¼Œè°ƒç”¨ææ„å‡½æ•°ï¼Œæ‰§è¡Œmutex::unlock()

### ä¸‰ã€æ­»é”

##### 3.1 æ­»é”æ¼”ç¤º

æ­»é”è‡³å°‘æœ‰ä¸¤ä¸ªäº’æ–¥é‡mutex1ï¼Œmutex2ã€‚

a.çº¿ç¨‹Aæ‰§è¡Œæ—¶ï¼Œè¿™ä¸ªçº¿ç¨‹å…ˆé”mutex1ï¼Œå¹¶ä¸”é”æˆåŠŸäº†ï¼Œç„¶åå»é”mutex2çš„æ—¶å€™ï¼Œå‡ºç°äº†ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

b.çº¿ç¨‹Bæ‰§è¡Œï¼Œè¿™ä¸ªçº¿ç¨‹å…ˆé”mutex2ï¼Œå› ä¸ºmutex2æ²¡æœ‰è¢«é”ï¼Œå³mutex2å¯ä»¥è¢«é”æˆåŠŸï¼Œç„¶åçº¿ç¨‹Bè¦å»é”mutex1.

c.æ­¤æ—¶ï¼Œæ­»é”äº§ç”Ÿäº†ï¼ŒAé”ç€mutex1ï¼Œéœ€è¦é”mutex2ï¼ŒBé”ç€mutex2ï¼Œéœ€è¦é”mutex1ï¼Œä¸¤ä¸ªçº¿ç¨‹æ²¡åŠæ³•ç»§ç»­è¿è¡Œä¸‹å»ã€‚ã€‚ã€‚

##### 3.2 æ­»é”çš„ä¸€èˆ¬è§£å†³æ–¹æ¡ˆï¼š

åªè¦ä¿è¯å¤šä¸ªäº’æ–¥é‡ä¸Šé”çš„é¡ºåºä¸€æ ·å°±ä¸ä¼šé€ æˆæ­»é”ã€‚

##### 3.3 std::lock()å‡½æ•°æ¨¡æ¿

std::lock(mutex1,mutex2â€¦â€¦); ä¸€æ¬¡é”å®šå¤šä¸ªäº’æ–¥é‡ï¼ˆä¸€èˆ¬è¿™ç§æƒ…å†µå¾ˆå°‘ï¼‰ï¼Œç”¨äºå¤„ç†å¤šä¸ªäº’æ–¥é‡ã€‚
å¦‚æœäº’æ–¥é‡ä¸­ä¸€ä¸ªæ²¡é”ä½ï¼Œå®ƒå°±ç­‰ç€ï¼Œç­‰æ‰€æœ‰äº’æ–¥é‡éƒ½é”ä½ï¼Œæ‰èƒ½ç»§ç»­æ‰§è¡Œã€‚å¦‚æœæœ‰ä¸€ä¸ªæ²¡é”ä½ï¼Œå°±ä¼šæŠŠå·²ç»é”ä½çš„é‡Šæ”¾æ‰ï¼ˆè¦ä¹ˆäº’æ–¥é‡éƒ½é”ä½ï¼Œè¦ä¹ˆéƒ½æ²¡é”ä½ï¼Œé˜²æ­¢æ­»é”ï¼‰

##### 3.4 std::lock_guardçš„std::adopt_lockå‚æ•°

`std::lock_guard<std::mutex> my_guard(my_mutex,std::adopt_lock);`
åŠ å…¥adopt_lockåï¼Œåœ¨è°ƒç”¨lock_guardçš„æ„é€ å‡½æ•°æ—¶ï¼Œä¸å†è¿›è¡Œlock();
adopt_guardä¸ºç»“æ„ä½“å¯¹è±¡ï¼Œèµ·ä¸€ä¸ªæ ‡è®°ä½œç”¨ï¼Œè¡¨ç¤ºè¿™ä¸ªäº’æ–¥é‡å·²ç»lock()ï¼Œä¸éœ€è¦åœ¨lock()ã€‚

```
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
using namespace std;

class A{
public:
	void inMsgRecvQueue()
	{
		for (int i = 0; i < 100000; ++i)
		{
			cout << "æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’æ’å…¥ä¸€ä¸ªå…ƒç´ " << i << endl;
			{
				//lock_guard<mutex> sbguard(myMutex1, adopt_lock);
				lock(myMutex1, myMutex2);
				//myMutex2.lock();
				//myMutex1.lock();
				msgRecvQueue.push_back(i);
				myMutex1.unlock();
				myMutex2.unlock();
			}
		}
	}
	bool outMsgLULProc()
	{
		myMutex1.lock();
		myMutex2.lock();
		if (!msgRecvQueue.empty())
		{
			cout << "åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ åˆ é™¤å…ƒç´ " << msgRecvQueue.front() << endl;
			msgRecvQueue.pop_front();
			myMutex2.unlock();
			myMutex1.unlock();
			return true;
		}
		myMutex2.unlock();
		myMutex1.unlock();
		return false;
	}

	void outMsgRecvQueue()
	{
		for (int i = 0; i < 100000; ++i)
		{
			if (outMsgLULProc())
			{

			}
			else
			{
				cout << "ç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºç©ºæ•°ç»„ä¸ºç©º" << endl;
			}
		}
	}
private:
	list<int> msgRecvQueue;
	mutex myMutex1;
	mutex myMutex2;
};

int main()
{
	A myobja;
	mutex myMutex;
	thread myOutMsgObj(&A::outMsgRecvQueue, &myobja);
	thread myInMsgObj(&A::inMsgRecvQueue, &myobja);
	myOutMsgObj.join();
	myInMsgObj.join();
	return 0;
}

```

## 6. unique_lockï¼ˆç±»æ¨¡æ¿ï¼‰è¯¦è§£

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/fd.png)

#### 1.unique_lockå–ä»£lock_guard

unique_lockæ¯”lock_guardçµæ´»å¾ˆå¤šï¼ˆå¤šå‡ºæ¥å¾ˆå¤šç”¨æ³•ï¼‰ï¼Œæ•ˆç‡å·®ä¸€ç‚¹ã€‚

unique_lock<mutex> myUniLock(myMutex);

#### 2.unique_lockçš„ç¬¬äºŒä¸ªå‚æ•°

##### 2.1 std::adopt_lockï¼š

è¡¨ç¤ºè¿™ä¸ªäº’æ–¥é‡å·²ç»è¢«lock()ï¼Œå³ä¸éœ€è¦åœ¨æ„é€ å‡½æ•°ä¸­lockè¿™ä¸ªäº’æ–¥é‡äº†ã€‚

å‰æï¼šå¿…é¡»æå‰lock

lock_guardä¸­ä¹Ÿå¯ä»¥ç”¨è¿™ä¸ªå‚æ•°

`my_mutex1.lock()`

`std::lock_guard<std::mutex> sbguard1(my_mutex1, std::adopt_lock)`

##### 2.2 std::try_to_lockï¼š

å°è¯•ç”¨mutexçš„lock()å»é”å®šè¿™ä¸ªmutexï¼Œä½†å¦‚æœæ²¡æœ‰é”å®šæˆåŠŸï¼Œä¼šç«‹å³è¿”å›ï¼Œä¸ä¼šé˜»å¡åœ¨é‚£é‡Œï¼›
ä½¿ç”¨try_to_lockçš„åŸå› æ˜¯é˜²æ­¢å…¶ä»–çš„çº¿ç¨‹é”å®šmutexå¤ªé•¿æ—¶é—´ï¼Œå¯¼è‡´æœ¬çº¿ç¨‹ä¸€ç›´é˜»å¡åœ¨lockè¿™ä¸ªåœ°æ–¹

å‰æï¼šä¸èƒ½æå‰lock();

owns_locks()æ–¹æ³•åˆ¤æ–­æ˜¯å¦æ‹¿åˆ°é”ï¼Œå¦‚æ‹¿åˆ°è¿”å›true

```
// my_mutex1.lock()  ä¸èƒ½æå‰lock
std::lock_guard<std::mutex> sbguard1(my_mutex1, std::try_to_lock)
if(sbguard1.owns_lock()){
//æ‹¿åˆ°äº†é”ï¼Œå¯ä»¥æ“ä½œå…±äº«æ•°æ®
}
else{
// æ²¡æœ‰æ‹¿åˆ°é”å¹²äº›åˆ«çš„äº‹
}
```

##### 2.3 std::defer_lockï¼š

å¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªå‚æ•°å°±å¯¹mutexè¿›è¡ŒåŠ é”ï¼ŒåŠ ä¸Šdefer_lockæ˜¯å§‹åŒ–äº†ä¸€ä¸ªæ²¡æœ‰åŠ é”çš„mutex
ä¸ç»™å®ƒåŠ é”çš„ç›®çš„æ˜¯ä»¥åå¯ä»¥è°ƒç”¨unique_lockçš„ä¸€äº›æ–¹æ³•

å‰æï¼šä¸èƒ½æå‰lock



#### 3.unique_lockçš„æˆå‘˜å‡½æ•°ï¼ˆå‰ä¸‰ä¸ªä¸std::defer_lockè”åˆä½¿ç”¨ï¼‰

##### 3.1 lock()ï¼šåŠ é”ã€‚

```
unique_lock<mutex> myUniLock(myMutexï¼Œ defer_lock);
myUniLock.lock();

```

ä¸ç”¨è‡ªå·±unlock();

##### *3.2 unlock()ï¼šè§£é”ã€‚*

```
unique_lock<mutex> myUniLock(myMutexï¼Œ defer_lock);
myUniLock.lock();
//å¤„ç†ä¸€äº›å…±äº«ä»£ç 
myUniLock.unlock(); // ä¸´æ—¶å¤„ç†éå…±äº«ä»£ç 
//å¤„ç†ä¸€äº›éå…±äº«ä»£ç 
myUniLock.lock();
//å¤„ç†ä¸€äº›å…±äº«ä»£ç 

```

å› ä¸ºä¸€äº›éå…±äº«ä»£ç è¦å¤„ç†ï¼Œå¯ä»¥æš‚æ—¶å…ˆunlock()ï¼Œç”¨å…¶ä»–çº¿ç¨‹æŠŠå®ƒä»¬å¤„ç†äº†ï¼Œå¤„ç†å®Œåå†lock()ã€‚

##### 3.3 try_lock()ï¼šå°è¯•ç»™äº’æ–¥é‡åŠ é”

å¦‚æœæ‹¿ä¸åˆ°é”ï¼Œè¿”å›falseï¼Œå¦åˆ™è¿”å›trueã€‚

```
if(sbguard1.try_lock()==true){

}else{

}
```



##### 3.4 release()ï¼š

`unique_lock<mutex> myUniLock(myMutex);`

ç›¸å½“äºæŠŠmyMutexå’ŒmyUniLockç»‘å®šåœ¨äº†ä¸€èµ·ï¼Œrelease()å°±æ˜¯è§£é™¤ç»‘å®šï¼Œè¿”å›å®ƒæ‰€ç®¡ç†çš„mutexå¯¹è±¡çš„æŒ‡é’ˆï¼Œå¹¶é‡Šæ”¾æ‰€æœ‰æƒ

`mutex* ptx = myUniLock.release();`

æ‰€æœ‰æƒç”±ptxæ¥ç®¡ï¼Œå¦‚æœåŸæ¥mutexå¯¹è±¡å¤„ç†åŠ é”çŠ¶æ€ï¼Œå°±éœ€è¦ptxåœ¨ä»¥åè¿›è¡Œè§£é”äº†ã€‚
lockçš„ä»£ç æ®µè¶Šå°‘ï¼Œæ‰§è¡Œè¶Šå¿«ï¼Œæ•´ä¸ªç¨‹åºçš„è¿è¡Œæ•ˆç‡è¶Šé«˜ã€‚

a.é”ä½çš„ä»£ç å°‘ï¼Œå«åšç²’åº¦ç»†ï¼Œæ‰§è¡Œæ•ˆç‡é«˜ï¼›

b.é”ä½çš„ä»£ç å¤šï¼Œå«åšç²’åº¦ç²—ï¼Œæ‰§è¡Œæ•ˆç‡ä½ï¼›



#### 4.unique_lockæ‰€æœ‰æƒçš„ä¼ é€’

unique_lock<mutex> myUniLock(myMutex);æŠŠmyMutexå’ŒmyUniLockç»‘å®šåœ¨äº†ä¸€èµ·ï¼Œä¹Ÿå°±æ˜¯myUniLockæ‹¥æœ‰myMutexçš„æ‰€æœ‰æƒ

1. ##### ä½¿ç”¨moveè½¬ç§»

myUniLockæ‹¥æœ‰myMutexçš„æ‰€æœ‰æƒï¼ŒmyUniLockå¯ä»¥æŠŠè‡ªå·±å¯¹myMutexçš„æ‰€æœ‰æƒè½¬ç§»ï¼Œä½†æ˜¯ä¸èƒ½å¤åˆ¶ã€‚
unique_lock<mutex> myUniLock2(std::move(myUniLock));
ç°åœ¨myUniLock2æ‹¥æœ‰myMutexçš„æ‰€æœ‰æƒã€‚
2. ##### åœ¨å‡½æ•°ä¸­returnä¸€ä¸ªä¸´æ—¶å˜é‡ï¼Œå³å¯ä»¥å®ç°è½¬ç§»

  ```
  unique_lock<mutex> aFunction()
  {
      unique_lock<mutex> myUniLock(myMutex);
      //ç§»åŠ¨æ„é€ å‡½æ•°é‚£é‡Œè®²ä»å‡½æ•°è¿”å›ä¸€ä¸ªå±€éƒ¨çš„unique_lockå¯¹è±¡æ˜¯å¯ä»¥çš„
      //è¿”å›è¿™ç§å±€éƒ¨å¯¹è±¡ä¼šå¯¼è‡´ç³»ç»Ÿç”Ÿæˆä¸´æ—¶çš„unique_lockå¯¹è±¡ï¼Œå¹¶è°ƒç”¨unique_lockçš„ç§»åŠ¨æ„é€ å‡½æ•°
      return myUniLock;
  }
  // ç„¶åå°±å¯ä»¥åœ¨å¤–å±‚è°ƒç”¨ï¼Œåœ¨sbguardå…·æœ‰å¯¹myMutexçš„æ‰€æœ‰æƒ
  std::unique_lock<std::mutex> sbguard = aFunction();
  
  ```



## 7. å•ä¾‹è®¾è®¡æ¨¡å¼å…±äº«æ•°æ®åˆ†æã€è§£å†³ï¼Œcall_once

### 1.è®¾è®¡æ¨¡å¼

ç¨‹åºçµæ´»ï¼Œç»´æŠ¤èµ·æ¥å¯èƒ½æ–¹ä¾¿ï¼Œç”¨è®¾è®¡æ¨¡å¼ç†å¿µå†™å‡ºæ¥çš„ä»£ç å¾ˆæ™¦æ¶©ï¼Œä½†æ˜¯åˆ«äººæ¥ç®¡ã€é˜…è¯»ä»£ç éƒ½ä¼šå¾ˆç—›è‹¦

è€å¤–åº”ä»˜ç‰¹åˆ«å¤§çš„é¡¹ç›®æ—¶ï¼ŒæŠŠé¡¹ç›®çš„å¼€å‘ç»éªŒã€æ¨¡å—åˆ’åˆ†ç»éªŒï¼Œæ€»ç»“æ•´ç†æˆè®¾è®¡æ¨¡å¼

ä¸­å›½é›¶å‡ å¹´è®¾è®¡æ¨¡å¼åˆšå¼€å§‹ç«æ—¶ï¼Œæ€»å–œæ¬¢æ‹¿ä¸€ä¸ªè®¾è®¡æ¨¡å¼å¾€ä¸Šå¥—ï¼Œå¯¼è‡´ä¸€ä¸ªå°å°çš„é¡¹ç›®æ€»è¦åŠ å‡ ä¸ªè®¾è®¡æ¨¡å¼ï¼Œæœ¬æœ«å€’ç½®

è®¾è®¡æ¨¡å¼æœ‰å…¶ç‹¬ç‰¹çš„ä¼˜ç‚¹ï¼Œè¦æ´»å­¦æ´»ç”¨ï¼Œä¸è¦æ·±é™·å…¶ä¸­ï¼Œç”Ÿæ¬ç¡¬å¥—

### 2.å•ä¾‹è®¾è®¡æ¨¡å¼ï¼š

æ•´ä¸ªé¡¹ç›®ä¸­ï¼Œæœ‰æŸä¸ªæˆ–è€…æŸäº›ç‰¹æ®Šçš„ç±»ï¼Œåªèƒ½åˆ›å»ºä¸€ä¸ªå±äºè¯¥ç±»çš„å¯¹è±¡ã€‚

å•ä¾‹ç±»ï¼šåªèƒ½ç”Ÿæˆä¸€ä¸ªå¯¹è±¡ã€‚



### 3.å•ä¾‹è®¾è®¡æ¨¡å¼å…±äº«æ•°æ®åˆ†æã€è§£å†³

é¢ä¸´é—®é¢˜ï¼šéœ€è¦åœ¨è‡ªå·±åˆ›å»ºçš„çº¿ç¨‹ä¸­æ¥åˆ›å»ºå•ä¾‹ç±»çš„å¯¹è±¡ï¼Œè¿™ç§çº¿ç¨‹å¯èƒ½ä¸æ­¢ä¸€ä¸ªã€‚æˆ‘ä»¬å¯èƒ½é¢ä¸´GetInstance()è¿™ç§æˆå‘˜å‡½æ•°éœ€è¦äº’æ–¥ã€‚

å¯ä»¥åœ¨åŠ é”å‰åˆ¤æ–­m_instanceæ˜¯å¦ä¸ºç©ºï¼Œå¦åˆ™æ¯æ¬¡è°ƒç”¨Singleton::getInstance()éƒ½è¦åŠ é”ï¼Œååˆ†å½±å“æ•ˆç‡ã€‚

```
#include <iostream>	
#include <mutex>
using namespace	std;

mutex myMutex;
//æ‡’æ±‰æ¨¡å¼
class Singleton
{
public:
	static Singleton * getInstance() {
         //åŒé‡é”å®š æé«˜æ•ˆç‡
		if (instance == NULL) {
			lock_guard<mutex> myLockGua(myMutex);
			if (instance == NULL) {
				instance = new Singleton;
			}
		}
		return instance;
	}
private:
	Singleton() {}
	static Singleton *instance;
};
Singleton * Singleton::instance = NULL;

//é¥¿æ±‰æ¨¡å¼
class Singleton2 {
public:
	static Singleton2* getInstance() {
		return instance;
	}
private:
	Singleton2() {}
	static Singleton2 * instance;
};
Singleton2 * Singleton2::instance = new Singleton2;

int main(void)
{
	Singleton * singer = Singleton::getInstance();
	Singleton * singer2 = Singleton::getInstance();
	if (singer == singer2)
		cout << "äºŒè€…æ˜¯åŒä¸€ä¸ªå®ä¾‹" << endl;
	else
		cout << "äºŒè€…ä¸æ˜¯åŒä¸€ä¸ªå®ä¾‹" << endl;

	cout << "----------		ä»¥ä¸‹ æ˜¯ é¥¿æ±‰å¼	------------" << endl;
	Singleton2 * singer3 = Singleton2::getInstance();
	Singleton2 * singer4 = Singleton2::getInstance();
	if (singer3 == singer4)
		cout << "äºŒè€…æ˜¯åŒä¸€ä¸ªå®ä¾‹" << endl;
	else
		cout << "äºŒè€…ä¸æ˜¯åŒä¸€ä¸ªå®ä¾‹" << endl;

	return 0;
}

```



å¦‚æœè§‰å¾—åœ¨å•ä¾‹æ¨¡å¼newäº†ä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ²¡æœ‰è‡ªå·±deleteæ‰ï¼Œè¿™æ ·ä¸åˆç†ã€‚å¯ä»¥å¢åŠ ä¸€ä¸ªç±»ä¸­ç±»CGarhuishouï¼Œnewä¸€ä¸ªå•ä¾‹ç±»æ—¶åˆ›å»ºä¸€ä¸ªé™æ€çš„CGarhuishouå¯¹è±¡ï¼Œè¿™æ ·åœ¨ç¨‹åºç»“æŸæ—¶ä¼šè°ƒç”¨CGarhuishouçš„ææ„å‡½æ•°ï¼Œé‡Šæ”¾æ‰newå‡ºæ¥çš„å•ä¾‹å¯¹è±¡ã€‚

```
class Singelton
{
public:
	static Singleton * getInstance() {
        if (instance == NULL) {
		    static CGarhuishou huishou;
		    instance = new Singelton;
        }
        return instance;
	}
	class CGarhuishou {
	public:
		~CGarhuishou()
		{
			if (Singleton::instance)
			{
				delete Singleton::instance;
				Singleton::instance = NULL;
			}
		}
	};
private:
	Singleton() {}
	static Singleton *instance;
};
Singleton * Singleton::instance = NULL;

```



### 4.std::call_once()ï¼š

å‡½æ•°æ¨¡æ¿ï¼Œè¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ ‡è®°ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°åï¼ˆå¦‚a()ï¼‰ã€‚
åŠŸèƒ½ï¼šèƒ½å¤Ÿä¿è¯å‡½æ•°a()åªè¢«è°ƒç”¨ä¸€æ¬¡ã€‚å…·å¤‡äº’æ–¥é‡çš„èƒ½åŠ›ï¼Œè€Œä¸”æ¯”äº’æ–¥é‡æ¶ˆè€—çš„èµ„æºæ›´å°‘ï¼Œæ›´é«˜æ•ˆã€‚
call_once()éœ€è¦ä¸ä¸€ä¸ªæ ‡è®°ç»“åˆä½¿ç”¨ï¼Œè¿™ä¸ªæ ‡è®°ä¸ºstd::once_flagï¼›å…¶å®once_flagæ˜¯ä¸€ä¸ªç»“æ„ï¼Œcall_once()å°±æ˜¯é€šè¿‡æ ‡è®°æ¥å†³å®šå‡½æ•°æ˜¯å¦æ‰§è¡Œï¼Œè°ƒç”¨æˆåŠŸåï¼Œå°±æŠŠæ ‡è®°è®¾ç½®ä¸ºä¸€ç§å·²è°ƒç”¨çŠ¶æ€ã€‚

å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œæ—¶ï¼Œä¸€ä¸ªçº¿ç¨‹ä¼šç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹å…ˆæ‰§è¡Œã€‚

```
once_flag g_flag;
class Singleton
{
public:
    static void CreateInstance()//call_onceä¿è¯å…¶åªè¢«è°ƒç”¨ä¸€æ¬¡
    {
        instance = new Singleton;
    }
    //ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œåˆ°è¿™é‡Œï¼Œå…¶ä¸­ä¸€ä¸ªçº¿ç¨‹è¦ç­‰å¦å¤–ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œæ¯•
	static Singleton * getInstance() {
         call_once(g_flag, CreateInstance);
         return instance;
	}
private:
	Singleton() {}
	static Singleton *instance;
};
Singleton * Singleton::instance = NULL;

```

## 8. condition_variableã€waitã€notify_oneã€notify_all

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/asdfasd.png)

### **ä¸€ã€æ¡ä»¶å˜é‡condition_variableã€waitã€notify_oneã€notify_all**

std::condition_variableå®é™…ä¸Šæ˜¯ä¸€ä¸ªç±»ï¼Œæ˜¯ä¸€ä¸ªå’Œæ¡ä»¶ç›¸å…³çš„ç±»ï¼Œè¯´ç™½äº†å°±æ˜¯ç­‰å¾…ä¸€ä¸ªæ¡ä»¶è¾¾æˆã€‚

```
std::mutex mymutex1;
std::unique_lock<std::mutex> sbguard1(mymutex1);
std::condition_variable condition;
condition.wait(sbguard1, [this] {if (!msgRecvQueue.empty())
                                    return true;
                                return false;
                                });
 
condition.wait(sbguard1);

```

wait()ç”¨æ¥ç­‰ä¸€ä¸ªä¸œè¥¿

å¦‚æœç¬¬äºŒä¸ªå‚æ•°çš„lambdaè¡¨è¾¾å¼è¿”å›å€¼æ˜¯falseï¼Œé‚£ä¹ˆwait()å°†è§£é”äº’æ–¥é‡ï¼Œå¹¶é˜»å¡åˆ°æœ¬è¡Œ
å¦‚æœç¬¬äºŒä¸ªå‚æ•°çš„lambdaè¡¨è¾¾å¼è¿”å›å€¼æ˜¯trueï¼Œé‚£ä¹ˆwait()ç›´æ¥è¿”å›å¹¶ç»§ç»­æ‰§è¡Œã€‚

é˜»å¡åˆ°ä»€ä¹ˆæ—¶å€™ä¸ºæ­¢å‘¢ï¼Ÿé˜»å¡åˆ°å…¶ä»–æŸä¸ªçº¿ç¨‹è°ƒç”¨notify_one()æˆå‘˜å‡½æ•°ä¸ºæ­¢ï¼›

å¦‚æœæ²¡æœ‰ç¬¬äºŒä¸ªå‚æ•°ï¼Œé‚£ä¹ˆæ•ˆæœè·Ÿç¬¬äºŒä¸ªå‚æ•°lambdaè¡¨è¾¾å¼è¿”å›falseæ•ˆæœä¸€æ ·

wait()å°†è§£é”äº’æ–¥é‡ï¼Œå¹¶é˜»å¡åˆ°æœ¬è¡Œï¼Œé˜»å¡åˆ°å…¶ä»–æŸä¸ªçº¿ç¨‹è°ƒç”¨notify_one()æˆå‘˜å‡½æ•°ä¸ºæ­¢ã€‚

å½“å…¶ä»–çº¿ç¨‹ç”¨notify_one()å°†æœ¬çº¿ç¨‹wait()å”¤é†’åï¼Œè¿™ä¸ªwaitæ¢å¤å

1ã€wait()ä¸æ–­å°è¯•è·å–äº’æ–¥é‡é”ï¼Œå¦‚æœè·å–ä¸åˆ°é‚£ä¹ˆæµç¨‹å°±å¡åœ¨wait()è¿™é‡Œç­‰å¾…è·å–ï¼Œå¦‚æœè·å–åˆ°äº†ï¼Œé‚£ä¹ˆwait()å°±ç»§ç»­æ‰§è¡Œï¼Œè·å–åˆ°äº†é”

2.1ã€å¦‚æœwaitæœ‰ç¬¬äºŒä¸ªå‚æ•°å°±åˆ¤æ–­è¿™ä¸ªlambdaè¡¨è¾¾å¼ã€‚

a)å¦‚æœè¡¨è¾¾å¼ä¸ºfalseï¼Œé‚£waitåˆå¯¹äº’æ–¥é‡è§£é”ï¼Œç„¶ååˆä¼‘çœ ï¼Œç­‰å¾…å†æ¬¡è¢«notify_one()å”¤é†’
b)å¦‚æœlambdaè¡¨è¾¾å¼ä¸ºtrueï¼Œåˆ™waitè¿”å›ï¼Œæµç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œï¼ˆæ­¤æ—¶äº’æ–¥é‡å·²è¢«é”ä½ï¼‰ã€‚
2.2ã€å¦‚æœwaitæ²¡æœ‰ç¬¬äºŒä¸ªå‚æ•°ï¼Œåˆ™waitè¿”å›ï¼Œæµç¨‹èµ°ä¸‹å»ã€‚

æµç¨‹åªè¦èµ°åˆ°äº†wait()ä¸‹é¢åˆ™äº’æ–¥é‡ä¸€å®šè¢«é”ä½äº†ã€‚

```
#include <thread>
#include <iostream>
#include <list>
#include <mutex>
using namespace std;
 
class A {
public:
    void inMsgRecvQueue() {
        for (int i = 0; i < 100000; ++i) 
        {
            cout << "inMsgRecvQueueæ’å…¥ä¸€ä¸ªå…ƒç´ " << i << endl;

            std::unique_lock<std::mutex> sbguard1(mymutex1);
            msgRecvQueue.push_back(i); 
            //å°è¯•æŠŠwait()çº¿ç¨‹å”¤é†’,æ‰§è¡Œå®Œè¿™è¡Œï¼Œ
            //é‚£ä¹ˆoutMsgRecvQueue()é‡Œçš„waitå°±ä¼šè¢«å”¤é†’
            //åªæœ‰å½“å¦å¤–ä¸€ä¸ªçº¿ç¨‹æ­£åœ¨æ‰§è¡Œwait()æ—¶notify_one()æ‰ä¼šèµ·æ•ˆï¼Œå¦åˆ™æ²¡æœ‰ä½œç”¨
            condition.notify_one();
        }
	}
 
	void outMsgRecvQueue() {
        int command = 0;
        while (true) {
            std::unique_lock<std::mutex> sbguard2(mymutex1);
            // wait()ç”¨æ¥ç­‰ä¸€ä¸ªä¸œè¥¿
            // å¦‚æœç¬¬äºŒä¸ªå‚æ•°çš„lambdaè¡¨è¾¾å¼è¿”å›å€¼æ˜¯falseï¼Œé‚£ä¹ˆwait()å°†è§£é”äº’æ–¥é‡ï¼Œå¹¶é˜»å¡åˆ°æœ¬è¡Œ
            // é˜»å¡åˆ°ä»€ä¹ˆæ—¶å€™ä¸ºæ­¢å‘¢ï¼Ÿé˜»å¡åˆ°å…¶ä»–æŸä¸ªçº¿ç¨‹è°ƒç”¨notify_one()æˆå‘˜å‡½æ•°ä¸ºæ­¢ï¼›
            //å½“ wait() è¢« notify_one() æ¿€æ´»æ—¶ï¼Œä¼šå…ˆæ‰§è¡Œå®ƒçš„ æ¡ä»¶åˆ¤æ–­è¡¨è¾¾å¼ æ˜¯å¦ä¸º trueï¼Œ
            //å¦‚æœä¸ºtrueæ‰ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œ
            condition.wait(sbguard2, [this] {
                if (!msgRecvQueue.empty())
                    return true;
                return false;});
            command = msgRecvQueue.front();
            msgRecvQueue.pop_front();
            //å› ä¸ºunique_lockçš„çµæ´»æ€§ï¼Œæˆ‘ä»¬å¯ä»¥éšæ—¶unlockï¼Œä»¥å…é”ä½å¤ªé•¿æ—¶é—´
            sbguard2.unlock(); 
            cout << "outMsgRecvQueue()æ‰§è¡Œï¼Œå–å‡ºç¬¬ä¸€ä¸ªå…ƒç´ " << endl;
        }
	}
 
private:
	std::list<int> msgRecvQueue;
	std::mutex mymutex1;
	std::condition_variable condition;
};

int main() {
	A myobja;
	std::thread myoutobj(&A::outMsgRecvQueue, &myobja);
	std::thread myinobj(&A::inMsgRecvQueue, &myobja);
	myinobj.join();
	myoutobj.join();
}

```

### äºŒã€æ·±å…¥æ€è€ƒ

ä¸Šé¢çš„ä»£ç å¯èƒ½å¯¼è‡´å‡ºç°ä¸€ç§æƒ…å†µï¼š
å› ä¸ºoutMsgRecvQueue()ä¸inMsgRecvQueue()å¹¶ä¸æ˜¯ä¸€å¯¹ä¸€æ‰§è¡Œçš„ï¼Œæ‰€ä»¥å½“ç¨‹åºå¾ªç¯æ‰§è¡Œå¾ˆå¤šæ¬¡ä»¥åï¼Œå¯èƒ½åœ¨msgRecvQueue ä¸­å·²ç»æœ‰äº†å¾ˆå¤šæ¶ˆæ¯ï¼Œä½†æ˜¯ï¼ŒoutMsgRecvQueueè¿˜æ˜¯è¢«å”¤é†’ä¸€æ¬¡åªå¤„ç†ä¸€æ¡æ•°æ®ã€‚è¿™æ—¶å¯ä»¥è€ƒè™‘æŠŠoutMsgRecvQueueå¤šæ‰§è¡Œå‡ æ¬¡ï¼Œæˆ–è€…å¯¹inMsgRecvQueueè¿›è¡Œé™æµã€‚

### ä¸‰ã€notify_all()

notify_one()ï¼šé€šçŸ¥ä¸€ä¸ªçº¿ç¨‹çš„wait()

notify_all()ï¼šé€šçŸ¥æ‰€æœ‰çº¿ç¨‹çš„wait()


## 9. asyncã€futureã€packaged_taskã€promise

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/bdz.png)

**æœ¬èŠ‚å†…å®¹éœ€è¦åŒ…å«å¤´æ–‡ä»¶#include <future>**

### ä¸€ã€std::asyncã€std::futureåˆ›å»ºåå°ä»»åŠ¡å¹¶è¿”å›å€¼

std::asyncæ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œç”¨æ¥å¯åŠ¨ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ï¼Œå¯åŠ¨èµ·æ¥ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ä¹‹åï¼Œå®ƒè¿”å›ä¸€ä¸ªstd::futureå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯ä¸ªç±»æ¨¡æ¿ã€‚

ä»€ä¹ˆå«â€œå¯åŠ¨ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡â€ï¼Ÿå°±æ˜¯è‡ªåŠ¨åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶å¼€å§‹ æ‰§è¡Œå¯¹åº”çš„çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œå®ƒè¿”å›ä¸€ä¸ªstd::futureå¯¹è±¡ï¼Œè¿™ä¸ªstd::futureå¯¹è±¡ä¸­å°±å«æœ‰çº¿ç¨‹å…¥å£å‡½æ•°æ‰€è¿”å›çš„ç»“æœï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨futureå¯¹è±¡çš„æˆå‘˜å‡½æ•°get()æ¥è·å–ç»“æœã€‚

â€œfutureâ€å°†æ¥çš„æ„æ€ï¼Œä¹Ÿæœ‰äººç§°å‘¼std::futureæä¾›äº†ä¸€ç§è®¿é—®å¼‚æ­¥æ“ä½œç»“æœçš„æœºåˆ¶ï¼Œå°±æ˜¯è¯´è¿™ä¸ªç»“æœä½ å¯èƒ½æ²¡åŠæ³•é©¬ä¸Šæ‹¿åˆ°ï¼Œä½†æ˜¯åœ¨ä¸ä¹…çš„å°†æ¥ï¼Œè¿™ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œæ¯•çš„æ—¶å€™ï¼Œä½ å°±èƒ½å¤Ÿæ‹¿åˆ°ç»“æœäº†ï¼Œæ‰€ä»¥ï¼Œå¤§å®¶è¿™ä¹ˆç†è§£ï¼šfutureä¸­ä¿å­˜ç€ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼æ˜¯åœ¨å°†æ¥çš„æŸä¸ªæ—¶åˆ»èƒ½å¤Ÿæ‹¿åˆ°ã€‚

std::futureå¯¹è±¡çš„get()æˆå‘˜å‡½æ•°ä¼šç­‰å¾…çº¿ç¨‹æ‰§è¡Œç»“æŸå¹¶è¿”å›ç»“æœï¼Œæ‹¿ä¸åˆ°ç»“æœå®ƒå°±ä¼šä¸€ç›´ç­‰å¾…ï¼Œæ„Ÿè§‰æœ‰ç‚¹åƒjoin()ã€‚ä½†æ˜¯ï¼Œå®ƒæ˜¯å¯ä»¥è·å–ç»“æœçš„ã€‚

std::futureå¯¹è±¡çš„wait()æˆå‘˜å‡½æ•°ï¼Œç”¨äºç­‰å¾…çº¿ç¨‹è¿”å›ï¼Œæœ¬èº«å¹¶ä¸è¿”å›ç»“æœï¼Œè¿™ä¸ªæ•ˆæœå’Œ std::thread çš„join()æ›´åƒã€‚

```
#include <iostream>
#include <future>
using namespace std;
class A {
public:
	int mythread(int mypar) {
		cout << mypar << endl;
		return mypar;
	}
};
 
 
int mythread() {
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000); // 5s
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}
 
 
int main() {
	A a;
	int tmp = 12;
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::future<int> result1 = std::async(mythread);
	cout << "continue........" << endl;
	cout << result1.get() << endl; //å¡åœ¨è¿™é‡Œç­‰å¾…mythread()æ‰§è¡Œå®Œæ¯•ï¼Œæ‹¿åˆ°ç»“æœ
	
	//ç±»æˆå‘˜å‡½æ•°
	std::future<int> result2 = std::async(&A::mythread, &a, tmp); //ç¬¬äºŒä¸ªå‚æ•°æ˜¯å¯¹è±¡å¼•ç”¨æ‰èƒ½ä¿è¯çº¿ç¨‹é‡Œæ‰§è¡Œçš„æ˜¯åŒä¸€ä¸ªå¯¹è±¡
	cout << result2.get() << endl;
   //æˆ–è€…result2.wait();// åªèƒ½ç­‰å¾…ï¼Œä¸èƒ½è¿”å›å€¼
	cout << "good luck" << endl;
	return 0;
}

```

æˆ‘ä»¬é€šè¿‡å‘std::async()ä¼ é€’ä¸€ä¸ªå‚æ•°ï¼Œè¯¥å‚æ•°æ˜¯std::launchç±»å‹ï¼ˆæšä¸¾ç±»å‹ï¼‰ï¼Œæ¥è¾¾åˆ°ä¸€äº›ç‰¹æ®Šçš„ç›®çš„ï¼š

#### 1ã€std::lunch::deferredï¼š

ï¼ˆdeferæ¨è¿Ÿï¼Œå»¶æœŸï¼‰è¡¨ç¤ºçº¿ç¨‹å…¥å£å‡½æ•°çš„è°ƒç”¨ä¼šè¢«å»¶è¿Ÿï¼Œä¸€ç›´åˆ°std::futureçš„wait()æˆ–è€…get()å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼ˆç”±ä¸»çº¿ç¨‹è°ƒç”¨ï¼‰æ‰ä¼šæ‰§è¡Œï¼›å¦‚æœwait()æˆ–è€…get()æ²¡æœ‰è¢«è°ƒç”¨ï¼Œåˆ™ä¸ä¼šæ‰§è¡Œã€‚
å®é™…ä¸Šæ ¹æœ¬å°±æ²¡æœ‰åˆ›å»ºæ–°çº¿ç¨‹ã€‚std::launch::deferredæ„æ€æ—¶å»¶è¿Ÿè°ƒç”¨ï¼Œå¹¶æ²¡æœ‰åˆ›å»ºæ–°çº¿ç¨‹ï¼Œæ˜¯åœ¨ä¸»çº¿ç¨‹ä¸­è°ƒç”¨çš„çº¿ç¨‹å…¥å£å‡½æ•°ã€‚

```
#include <iostream>
#include <future>
using namespace std;
 
int mythread() {
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}
 
 
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::future<int> result1 = std::async(std::launch::deferred ,mythread);
	cout << "continue........" << endl;
	cout << result1.get() << endl; //å¡åœ¨è¿™é‡Œç­‰å¾…mythread()æ‰§è¡Œå®Œæ¯•ï¼Œæ‹¿åˆ°ç»“æœ
	cout << "good luck" << endl;
	return 0;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/asdfasdfasdfasdfasdf.png)

æ°¸è¿œéƒ½ä¼šå…ˆæ‰“å°å‡ºcontinueâ€¦ï¼Œç„¶åæ‰ä¼šæ‰“å°å‡ºmythread() startå’Œmythread() endç­‰ä¿¡æ¯ã€‚

#### *2ã€std::launch::asyncï¼Œåœ¨è°ƒç”¨asyncå‡½æ•°çš„æ—¶å€™å°±å¼€å§‹åˆ›å»ºæ–°çº¿ç¨‹ã€‚*

```
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::future<int> result1 = std::async(std::launch::async ,mythread);
	cout << "continue........" << endl;
	cout << result1.get() << endl; 
	cout << "good luck" << endl;
	return 0;
}

```

### **äºŒã€std::packaged_taskï¼šæ‰“åŒ…ä»»åŠ¡ï¼ŒæŠŠä»»åŠ¡åŒ…è£…èµ·æ¥ã€‚**

ç±»æ¨¡æ¿ï¼Œå®ƒçš„æ¨¡æ¿å‚æ•°æ˜¯å„ç§å¯è°ƒç”¨å¯¹è±¡ï¼Œé€šè¿‡packaged_taskæŠŠå„ç§å¯è°ƒç”¨å¯¹è±¡åŒ…è£…èµ·æ¥ï¼Œæ–¹ä¾¿å°†æ¥ä½œä¸ºçº¿ç¨‹å…¥å£å‡½æ•°æ¥è°ƒç”¨ã€‚

```
#include <thread>
#include <iostream>
#include <future>
using namespace std;
 
int mythread(int mypar) {
	cout << mypar << endl;
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}
 
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	//æˆ‘ä»¬æŠŠå‡½æ•°mythreadé€šè¿‡packaged_taskåŒ…è£…èµ·æ¥
    //å‚æ•°æ˜¯ä¸€ä¸ªintï¼Œè¿”å›å€¼ç±»å‹æ˜¯int
    std::packaged_task<int(int)> mypt(mythread);
	std::thread t1(std::ref(mypt), 1);
	t1.join();
	std::future<int> result = mypt.get_future(); 
	//std::futureå¯¹è±¡é‡ŒåŒ…å«æœ‰çº¿ç¨‹å…¥å£å‡½æ•°çš„è¿”å›ç»“æœï¼Œè¿™é‡Œresultä¿å­˜mythreadè¿”å›çš„ç»“æœã€‚
	cout << result.get() << endl;
   
	return 0;
}

```

*å¯è°ƒç”¨å¯¹è±¡å¯ç”±å‡½æ•°æ¢æˆlambdaè¡¨è¾¾å¼*

```
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::packaged_task<int(int)> mypt([](int mypar) {
		cout << mypar << endl;
		cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
		std::chrono::milliseconds dura(5000);
		std::this_thread::sleep_for(dura);
		cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
		return 5;
	}); 
	
	std::thread t1(std::ref(mypt), 1);
	t1.join();
	std::future<int> result = mypt.get_future(); 
	//std::futureå¯¹è±¡é‡ŒåŒ…å«æœ‰çº¿ç¨‹å…¥å£å‡½æ•°çš„è¿”å›ç»“æœï¼Œè¿™é‡Œresultä¿å­˜mythreadè¿”å›çš„ç»“æœã€‚
	
	cout << result.get() << endl;
 
	cout << "good luck" << endl;
	return 0;
}

```

packaged_taskåŒ…è£…èµ·æ¥çš„å¯è°ƒç”¨å¯¹è±¡è¿˜å¯ä»¥ç›´æ¥è°ƒç”¨ï¼Œä»è¿™ä¸ªè§’åº¦æ¥è®²ï¼Œpackaged_taskå¯¹è±¡ä¹Ÿæ˜¯ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡
*lambdaçš„ç›´æ¥è°ƒç”¨*

```
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::packaged_task<int(int)> mypt([](int mypar) {
		cout << mypar << endl;
		cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
		std::chrono::milliseconds dura(5000);
		std::this_thread::sleep_for(dura);
		cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
		return 5;
	}); 
 
	mypt(1);
	std::future<int> result = mypt.get_future();
	cout << result.get() << endl;
}

```

### ä¸‰ã€*std::promiseï¼Œç±»æ¨¡æ¿*

æˆ‘ä»¬èƒ½å¤Ÿåœ¨æŸä¸ªçº¿ç¨‹ä¸­ç»™å®ƒèµ‹å€¼ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥åœ¨å…¶ä»–çº¿ç¨‹ä¸­ï¼ŒæŠŠè¿™ä¸ªå€¼å–å‡ºæ¥

```
#include <thread>
#include <iostream>
#include <future>
using namespace std;
 
void mythread(std::promise<int> &tmp, int clac) {
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	int result = clac;
	tmp.set_value(result); //ç»“æœä¿å­˜åˆ°äº†tmpè¿™ä¸ªå¯¹è±¡ä¸­
	return;
}
 
vector<std::packaged_task<int(int)>> task_vec;
 
int main() {
	std::promise<int> myprom;
	std::thread t1(mythread, std::ref(myprom), 180);
	t1.join(); //åœ¨è¿™é‡Œçº¿ç¨‹å·²ç»æ‰§è¡Œå®Œäº†
	std::future<int> fu1 = myprom.get_future(); //promiseå’Œfutureç»‘å®šï¼Œç”¨äºè·å–çº¿ç¨‹è¿”å›å€¼
	auto result = fu1.get();
	cout << "result = " << result << endl;
}

```

æ€»ç»“ï¼šé€šè¿‡promiseä¿å­˜ä¸€ä¸ªå€¼ï¼Œåœ¨å°†æ¥æŸä¸ªæ—¶åˆ»æˆ‘ä»¬é€šè¿‡æŠŠä¸€ä¸ªfutureç»‘å®šåˆ°è¿™ä¸ªpromiseä¸Šï¼Œæ¥å¾—åˆ°ç»‘å®šçš„å€¼

æ³¨æ„ï¼šä½¿ç”¨threadæ—¶ï¼Œå¿…é¡» join() æˆ–è€… detach() å¦åˆ™ç¨‹åºä¼šæŠ¥å¼‚å¸¸

å°ç»“ï¼š

æˆ‘ä»¬å­¦ä¹ è¿™äº›ä¸œè¥¿çš„ç›®çš„å¹¶ä¸æ˜¯ï¼Œè¦æŠŠä»–ä»¬éƒ½ç”¨åˆ°å®é™…å¼€å‘ä¸­ã€‚

ç›¸åï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿç”¨æœ€å°‘çš„ä¸œè¥¿å†™å‡ºä¸€ä¸ªç¨³å®šçš„ï¼Œé«˜æ•ˆçš„å¤šçº¿ç¨‹ç¨‹åºï¼Œæ›´å€¼å¾—èµèµã€‚

æˆ‘ä»¬ä¸ºäº†æˆé•¿å¿…é¡»é˜…è¯»ä¸€äº›é«˜æ‰‹å†™çš„ä»£ç ï¼Œä»è€Œå®ç°è‡ªå·±ä»£ç çš„ç§¯ç´¯ï¼›


## 10. futureå…¶ä»–æˆå‘˜å‡½æ•°ã€shared_futureã€atomic

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/hdfs.png)

### ä¸€ã€std::future çš„æˆå‘˜å‡½æ•°

1ã€std::future_status status = result.wait_for(std::chrono::seconds(å‡ ç§’));
å¡ä½å½“å‰æµç¨‹ï¼Œç­‰å¾…std::async()çš„å¼‚æ­¥ä»»åŠ¡è¿è¡Œä¸€æ®µæ—¶é—´ï¼Œç„¶åè¿”å›å…¶çŠ¶æ€std::future_statusã€‚å¦‚æœstd::async()çš„å‚æ•°æ˜¯std::launch::deferredï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼‰ï¼Œåˆ™ä¸ä¼šå¡ä½ä¸»æµç¨‹ã€‚
std::future_statusæ˜¯æšä¸¾ç±»å‹ï¼Œè¡¨ç¤ºå¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡ŒçŠ¶æ€ã€‚ç±»å‹çš„å–å€¼æœ‰
std::future_status::timeout
std::future_status::ready
std::future_status::deferred

```
#include <iostream>
#include <future>
using namespace std;
 
int mythread() {
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}

int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::future<int> result = std::async(mythread);
	cout << "continue........" << endl;
	//cout << result1.get() << endl; //å¡åœ¨è¿™é‡Œç­‰å¾…mythread()æ‰§è¡Œå®Œæ¯•ï¼Œæ‹¿åˆ°ç»“æœ
	//ç­‰å¾…1ç§’
    std::future_status status = result.wait_for(std::chrono::seconds(1));
	if (status == std::future_status::timeout) {
		//è¶…æ—¶ï¼šè¡¨ç¤ºçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œ
		cout << "è¶…æ—¶äº†ï¼Œçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œ" << endl;
	}
	//ç±»æˆå‘˜å‡½æ•°
	return 0;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/hddd.png)

```
#include <iostream>
#include <future>
using namespace std;
 
int mythread() {
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	//std::chrono::milliseconds dura(5000);
	//std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}
 
int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::future<int> result = std::async(std::launch::deferred, mythread);
	//std::future<int> result = std::async(mythread);
	cout << "continue........" << endl;
	//cout << result1.get() << endl; //å¡åœ¨è¿™é‡Œç­‰å¾…mythread()æ‰§è¡Œå®Œæ¯•ï¼Œæ‹¿åˆ°ç»“æœ
	std::future_status status = result.wait_for(std::chrono::seconds(6));
	if (status == std::future_status::timeout) {
		//è¶…æ—¶ï¼šè¡¨ç¤ºçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œ
		cout << "è¶…æ—¶äº†ï¼Œçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œ" << endl;
	}
	else if (status == std::future_status::ready) {
		//è¡¨ç¤ºçº¿ç¨‹æˆåŠŸè¿”å›
		cout << "çº¿ç¨‹æ‰§è¡ŒæˆåŠŸï¼Œè¿”å›" << endl;
		cout << result.get() << endl;
	}
	else if (status == std::future_status::deferred) {
		//å¦‚æœè®¾ç½® std::future<int> result = std::async(std::launch::deferred, mythread);ï¼Œåˆ™æœ¬æ¡ä»¶æˆç«‹
		cout << "çº¿ç¨‹å»¶è¿Ÿæ‰§è¡Œ" << endl;
		cout << result.get() << endl;
	}
 
	cout << "good luck" << endl;
	return 0;
}

```

get()åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œæ¯”å¦‚å¦‚æœ

```
auto a = result.get();
cout << result.get() << endl;

```

å°±ä¼šæŠ¥å‘Šå¼‚å¸¸
å› ä¸ºget()å‡½æ•°çš„è®¾è®¡æ˜¯ä¸€ä¸ªç§»åŠ¨è¯­ä¹‰ï¼Œç›¸å½“äºå°†resultä¸­çš„å€¼ç§»åŠ¨åˆ°äº†aä¸­ï¼Œå†æ¬¡getå°±æŠ¥å‘Šäº†å¼‚å¸¸ã€‚

### äºŒã€std::shared_futureï¼šä¹Ÿæ˜¯ä¸ªç±»æ¨¡æ¿

std::futureçš„ get() æˆå‘˜å‡½æ•°æ˜¯è½¬ç§»æ•°æ®

std::shared_future çš„ get()æˆå‘˜å‡½æ•°æ˜¯å¤åˆ¶æ•°æ®

```
#include <thread>
#include <iostream>
#include <future>
using namespace std;
 
int mythread() {
	cout << "mythread() start" << "threadid = " << std::this_thread::get_id() << endl;
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	cout << "mythread() end" << "threadid = " << std::this_thread::get_id() << endl;
	return 5;
}

int main() {
	cout << "main" << "threadid = " << std::this_thread::get_id() << endl;
	std::packaged_task<int()> mypt(mythread);
	std::thread t1(std::ref(mypt));
	std::future<int> result = mypt.get_future();
	
	bool ifcanget = result.valid(); //åˆ¤æ–­futureä¸­çš„å€¼æ˜¯ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆå€¼
	std::shared_future<int> result_s(result.share()); //æ‰§è¡Œå®Œæ¯•åresult_sé‡Œæœ‰å€¼ï¼Œè€Œresulté‡Œç©ºäº†
	//std::shared_future<int> result_s(std::move(result));
    //é€šè¿‡get_futureè¿”å›å€¼ç›´æ¥æ„é€ ä¸€ä¸ªshared_futureå¯¹è±¡
    //std::shared_future<int> result_s(mypt.get_future());
    t1.join();
	
	auto myresult1 = result_s.get();
	auto myresult2 = result_s.get();
 
	cout << "good luck" << endl;
	return 0;
}

```

### ä¸‰ã€std::atomicåŸå­æ“ä½œ

#### 3.1 åŸå­æ“ä½œæ¦‚å¿µå¼•å‡ºèŒƒä¾‹ï¼š

äº’æ–¥é‡ï¼šå¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ ç”¨äºä¿æŠ¤å…±äº«æ•°æ®ï¼šå…ˆé”ä½ï¼Œ æ“ä½œå…±äº«æ•°æ®ï¼Œ è§£é”ã€‚

æœ‰ä¸¤ä¸ªçº¿ç¨‹ï¼Œå¯¹ä¸€ä¸ªå˜é‡è¿›è¡Œæ“ä½œï¼Œä¸€ä¸ªçº¿ç¨‹è¯»è¿™ä¸ªå˜é‡çš„å€¼ï¼Œä¸€ä¸ªçº¿ç¨‹å¾€è¿™ä¸ªå˜é‡ä¸­å†™å€¼ã€‚

å³ä½¿æ˜¯ä¸€ä¸ªç®€å•å˜é‡çš„è¯»å–å’Œå†™å…¥æ“ä½œï¼Œå¦‚æœä¸åŠ é”ï¼Œä¹Ÿæœ‰å¯èƒ½ä¼šå¯¼è‡´è¯»å†™å€¼æ··ä¹±ï¼ˆä¸€æ¡Cè¯­å¥ä¼šè¢«æ‹†æˆ3ã€4æ¡æ±‡ç¼–è¯­å¥æ¥æ‰§è¡Œï¼Œæ‰€ä»¥ä»ç„¶æœ‰å¯èƒ½æ··ä¹±ï¼‰

```
#include <iostream>
#include <thread>
using namespace std;
int g_count = 0;
 
void mythread1() {
	for (int i = 0; i < 1000000; i++) {
		g_count++;
	}
}
 
int main() {
	std::thread t1(mythread1);
	std::thread t2(mythread1);
	t1.join();
	t2.join();
	cout << "æ­£å¸¸æƒ…å†µä¸‹ç»“æœåº”è¯¥æ˜¯200 0000æ¬¡ï¼Œå®é™…æ˜¯" << g_count << endl;
}

```



![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/hv.png)

ä½¿ç”¨mutexè§£å†³è¿™ä¸ªé—®é¢˜

```
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;
int g_count = 0;
std::mutex mymutex;

void mythread1() {
	for (int i = 0; i < 1000000; i++) {
		std::unique_lock<std::mutex> u1(mymutex);
		g_count++;
	}
}
 
 
int main() {
	std::thread t1(mythread1);
	std::thread t2(mythread1);
	t1.join();
	t2.join();
	cout << "æ­£å¸¸æƒ…å†µä¸‹ç»“æœåº”è¯¥æ˜¯200 0000æ¬¡ï¼Œå®é™…æ˜¯" << g_count << endl;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/n.png)



#### 3.2 åŸºæœ¬çš„std::atomicç”¨æ³•èŒƒä¾‹

å¤§å®¶å¯ä»¥æŠŠåŸå­æ“ä½œç†è§£æˆä¸€ç§ï¼šä¸éœ€è¦ç”¨åˆ°äº’æ–¥é‡åŠ é”ï¼ˆæ— é”ï¼‰æŠ€æœ¯çš„å¤šçº¿ç¨‹å¹¶å‘ç¼–ç¨‹æ–¹å¼ã€‚

åŸå­æ“ä½œï¼šåœ¨å¤šçº¿ç¨‹ä¸­ä¸ä¼šè¢«æ‰“æ–­çš„ç¨‹åºæ‰§è¡Œç‰‡æ®µã€‚

ä»æ•ˆç‡ä¸Šæ¥è¯´ï¼ŒåŸå­æ“ä½œè¦æ¯”äº’æ–¥é‡çš„æ–¹å¼æ•ˆç‡è¦é«˜ã€‚

äº’æ–¥é‡çš„åŠ é”ä¸€èˆ¬æ˜¯é’ˆå¯¹ä¸€ä¸ªä»£ç æ®µï¼Œè€ŒåŸå­æ“ä½œé’ˆå¯¹çš„ä¸€èˆ¬éƒ½æ˜¯ä¸€ä¸ªå˜é‡ã€‚

åŸå­æ“ä½œï¼Œä¸€èˆ¬éƒ½æ˜¯æŒ‡â€œä¸å¯åˆ†å‰²çš„æ“ä½œâ€ï¼›ä¹Ÿå°±æ˜¯è¯´è¿™ç§æ“ä½œçŠ¶æ€è¦ä¹ˆæ˜¯å®Œæˆçš„ï¼Œè¦ä¹ˆæ˜¯æ²¡å®Œæˆçš„ï¼Œä¸å¯èƒ½å‡ºç°åŠå®ŒæˆçŠ¶æ€ã€‚

std::atomicæ¥ä»£è¡¨åŸå­æ“ä½œï¼Œæ˜¯ä¸ªç±»æ¨¡æ¿ã€‚å…¶å®std::atomicæ˜¯ç”¨æ¥å°è£…æŸä¸ªç±»å‹çš„å€¼çš„

éœ€è¦æ·»åŠ #include <atomic>å¤´æ–‡ä»¶

èŒƒä¾‹ï¼š

```
#include <iostream>
#include <thread>
#include <atomic>
using namespace std;
std::atomic<int> g_count = 0; //å°è£…äº†ä¸€ä¸ªç±»å‹ä¸ºintçš„ å¯¹è±¡ï¼ˆå€¼ï¼‰

void mythread1() {
	for (int i = 0; i < 1000000; i++) {
		g_count++;
	}
}
 
int main() {
	std::thread t1(mythread1);
	std::thread t2(mythread1);
	t1.join();
	t2.join();
	cout << "æ­£å¸¸æƒ…å†µä¸‹ç»“æœåº”è¯¥æ˜¯200 0000æ¬¡ï¼Œå®é™…æ˜¯" << g_count << endl;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/hs.png)

```
#include <iostream>
#include <thread>
#include <atomic>
using namespace std;
std::atomic<bool> g_ifEnd = false; //å°è£…äº†ä¸€ä¸ªç±»å‹ä¸ºboolçš„ å¯¹è±¡ï¼ˆå€¼ï¼‰
 
void mythread() {
	std::chrono::milliseconds dura(1000);
	while (g_ifEnd == false) {
		cout << "thread id = " << std::this_thread::get_id() << "è¿è¡Œä¸­" << endl;
		std::this_thread::sleep_for(dura);
	}
	cout << "thread id = " << std::this_thread::get_id() << "è¿è¡Œç»“æŸ" << endl;
}
 
int main() {
	std::thread t1(mythread);
	std::thread t2(mythread);
	std::chrono::milliseconds dura(5000);
	std::this_thread::sleep_for(dura);
	g_ifEnd = true;
	cout << "ç¨‹åºæ‰§è¡Œå®Œæ¯•" << endl;
	t1.join();
	t2.join();
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/bf.png)

**æ€»ç»“ï¼š**
1ã€åŸå­æ“ä½œä¸€èˆ¬ç”¨äºè®¡æ•°æˆ–è€…ç»Ÿè®¡ï¼ˆå¦‚ç´¯è®¡å‘é€å¤šå°‘ä¸ªæ•°æ®åŒ…ï¼Œç´¯è®¡æ¥æ”¶åˆ°äº†å¤šå°‘ä¸ªæ•°æ®åŒ…ï¼‰ï¼Œå¤šä¸ªçº¿ç¨‹ä¸€èµ·ç»Ÿè®¡ï¼Œè¿™ç§æƒ…å†µå¦‚æœä¸ä½¿ç”¨åŸå­æ“ä½œä¼šå¯¼è‡´ç»Ÿè®¡å‘ç”Ÿæ··ä¹±ã€‚

2ã€å†™å•†ä¸šä»£ç æ—¶ï¼Œå¦‚æœä¸ç¡®å®šç»“æœçš„å½±å“ï¼Œæœ€å¥½è‡ªå·±å…ˆå†™ä¸€å°æ®µä»£ç è°ƒè¯•ã€‚æˆ–è€…ä¸è¦ä½¿ç”¨ã€‚

## 11. std::atomicç»­è°ˆã€std::asyncæ·±å…¥è°ˆ

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/ah.png)

### **ä¸€ã€std::atomicç»­è°ˆ**

```
#include <iostream>
#include <thread>
#include <atomic>
using namespace std;
std::atomic<int> g_count = 0; //å°è£…äº†ä¸€ä¸ªç±»å‹ä¸ºintçš„ å¯¹è±¡ï¼ˆå€¼ï¼‰
 
void mythread1() {
	for (int i = 0; i < 1000000; i++) {
		 //è™½ç„¶g_countä½¿ç”¨äº†åŸå­æ“ä½œæ¨¡æ¿ï¼Œä½†æ˜¯è¿™ç§å†™æ³•æ—¢è¯»åˆå†™ï¼Œ
		 //ä¼šå¯¼è‡´è®¡æ•°é”™è¯¯
         g_count = g_count + 1;
	}
}

int main() {
	std::thread t1(mythread1);
	std::thread t2(mythread1);
	t1.join();
	t2.join();
	cout << "æ­£å¸¸æƒ…å†µä¸‹ç»“æœåº”è¯¥æ˜¯200 0000æ¬¡ï¼Œå®é™…æ˜¯" << g_count << endl;
}

```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/vv.png)

ä¸€èˆ¬atomicåŸå­æ“ä½œï¼Œé’ˆå¯¹`++ï¼Œ--ï¼Œ+=ï¼Œ-=ï¼Œ&=ï¼Œ|=ï¼Œ^=`æ˜¯æ”¯æŒçš„ï¼Œå…¶ä»–æ“ä½œä¸ä¸€å®šæ”¯æŒã€‚

### äºŒã€std::asyncæ·±å…¥ç†è§£

#### 2.1 std::asyncå‚æ•°è¯¦è¿°ï¼Œasync ç”¨æ¥åˆ›å»ºä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡

å»¶è¿Ÿè°ƒç”¨å‚æ•° std::launch::deferredã€å»¶è¿Ÿè°ƒç”¨ã€‘ï¼Œstd::launch::asyncã€å¼ºåˆ¶åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ã€‘

std::async()æˆ‘ä»¬ä¸€èˆ¬ä¸å«åˆ›å»ºçº¿ç¨‹ï¼ˆä»–èƒ½å¤Ÿåˆ›å»ºçº¿ç¨‹ï¼‰ï¼Œæˆ‘ä»¬ä¸€èˆ¬å«å®ƒåˆ›å»ºä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ã€‚

std::asyncå’Œstd::threadæœ€æ˜æ˜¾çš„ä¸åŒï¼Œå°±æ˜¯ async **æœ‰æ—¶å€™**å¹¶ä¸åˆ›å»ºæ–°çº¿ç¨‹ã€‚åªä¼šä»å½“å‰çº¿ç¨‹ä½œä¸ºè¿›å…¥å£ ï¼Œå¯ä»¥ä½¿ç”¨std::this_thread::get_id()æŸ¥çœ‹ã€‚

â‘ å¦‚æœç”¨std::launch::deferred æ¥è°ƒç”¨asyncï¼Ÿ

å»¶è¿Ÿåˆ°è°ƒç”¨ get() æˆ–è€… wait() æ—¶æ‰§è¡Œï¼Œå¦‚æœä¸è°ƒç”¨å°±ä¸ä¼šæ‰§è¡Œ

â‘¡å¦‚æœç”¨std::launch::asyncæ¥è°ƒç”¨asyncï¼Ÿ

å¼ºåˆ¶è¿™ä¸ªå¼‚æ­¥ä»»åŠ¡åœ¨æ–°çº¿ç¨‹ä¸Šæ‰§è¡Œï¼Œè¿™æ„å‘³ç€ï¼Œç³»ç»Ÿå¿…é¡»è¦åˆ›å»ºå‡ºæ–°çº¿ç¨‹æ¥è¿è¡Œå…¥å£å‡½æ•°ã€‚

â‘¢å¦‚æœåŒæ—¶ç”¨ std::launch::async | std::launch::deferred

è¿™é‡Œè¿™ä¸ª | æ„å‘³ç€asyncçš„è¡Œä¸ºå¯èƒ½æ˜¯ std::launch::async åˆ›å»ºæ–°çº¿ç¨‹ç«‹å³æ‰§è¡Œï¼Œ ä¹Ÿå¯èƒ½æ˜¯ std::launch::deferred æ²¡æœ‰åˆ›å»ºæ–°çº¿ç¨‹å¹¶ä¸”å»¶è¿Ÿåˆ°è°ƒç”¨get()æ‰§è¡Œï¼Œç”±ç³»ç»Ÿæ ¹æ®å®é™…æƒ…å†µæ¥å†³å®šé‡‡å–å“ªç§æ–¹æ¡ˆ

â‘£ä¸å¸¦é¢å¤–å‚æ•° std::async(mythread)ï¼Œåªç»™async ä¸€ä¸ªå…¥å£å‡½æ•°åï¼Œæ­¤æ—¶çš„ç³»ç»Ÿç»™çš„é»˜è®¤å€¼æ˜¯ std::launch::async | std::launch::deferred å’Œ â‘¢ ä¸€æ ·ï¼Œæœ‰ç³»ç»Ÿè‡ªè¡Œå†³å®šå¼‚æ­¥è¿˜æ˜¯åŒæ­¥è¿è¡Œã€‚

#### 2.2 std::asyncå’Œstd::thread()åŒºåˆ«ï¼š

std::thread()å¦‚æœç³»ç»Ÿèµ„æºç´§å¼ å¯èƒ½å‡ºç°åˆ›å»ºçº¿ç¨‹å¤±è´¥çš„æƒ…å†µï¼Œå¦‚æœåˆ›å»ºçº¿ç¨‹å¤±è´¥é‚£ä¹ˆç¨‹åºå°±å¯èƒ½å´©æºƒï¼Œè€Œä¸”ä¸å®¹æ˜“æ‹¿åˆ°å‡½æ•°è¿”å›å€¼ï¼ˆä¸æ˜¯æ‹¿ä¸åˆ°ï¼‰
std::async()åˆ›å»ºå¼‚æ­¥ä»»åŠ¡ã€‚å¯èƒ½åˆ›å»ºçº¿ç¨‹ä¹Ÿå¯èƒ½ä¸åˆ›å»ºçº¿ç¨‹ï¼Œå¹¶ä¸”å®¹æ˜“æ‹¿åˆ°çº¿ç¨‹å…¥å£å‡½æ•°çš„è¿”å›å€¼ï¼›

ç”±äºç³»ç»Ÿèµ„æºé™åˆ¶ï¼š
â‘ å¦‚æœç”¨std::threadåˆ›å»ºçš„çº¿ç¨‹å¤ªå¤šï¼Œåˆ™å¯èƒ½åˆ›å»ºå¤±è´¥ï¼Œç³»ç»ŸæŠ¥å‘Šå¼‚å¸¸ï¼Œå´©æºƒã€‚

â‘¡å¦‚æœç”¨std::asyncï¼Œä¸€èˆ¬å°±ä¸ä¼šæŠ¥å¼‚å¸¸ï¼Œå› ä¸ºå¦‚æœç³»ç»Ÿèµ„æºç´§å¼ ï¼Œæ— æ³•åˆ›å»ºæ–°çº¿ç¨‹çš„æ—¶å€™ï¼Œasyncä¸åŠ é¢å¤–å‚æ•°çš„è°ƒç”¨æ–¹å¼å°±ä¸ä¼šåˆ›å»ºæ–°çº¿ç¨‹ã€‚è€Œæ˜¯åœ¨åç»­è°ƒç”¨get()è¯·æ±‚ç»“æœæ—¶æ‰§è¡Œåœ¨è¿™ä¸ªè°ƒç”¨get()çš„çº¿ç¨‹ä¸Šã€‚

å¦‚æœä½ å¼ºåˆ¶asyncä¸€å®šè¦åˆ›å»ºæ–°çº¿ç¨‹å°±è¦ä½¿ç”¨ std::launch::async æ ‡è®°ã€‚æ‰¿å—çš„ä»£ä»·æ˜¯ï¼Œç³»ç»Ÿèµ„æºç´§å¼ æ—¶å¯èƒ½å´©æºƒã€‚

â‘¢æ ¹æ®ç»éªŒï¼Œä¸€ä¸ªç¨‹åºä¸­çº¿ç¨‹æ•°é‡ ä¸å®œè¶…è¿‡100~200 ã€‚

#### 2.3 asyncä¸ç¡®å®šæ€§é—®é¢˜çš„è§£å†³

ä¸åŠ é¢å¤–å‚æ•°çš„asyncè°ƒç”¨æ—¶è®©ç³»ç»Ÿè‡ªè¡Œå†³å®šï¼Œæ˜¯å¦åˆ›å»ºæ–°çº¿ç¨‹ã€‚

std::future<int> result = std::async(mythread);
é—®é¢˜ç„¦ç‚¹åœ¨äºè¿™ä¸ªå†™æ³•ï¼Œä»»åŠ¡åˆ°åº•æœ‰æ²¡æœ‰è¢«æ¨è¿Ÿæ‰§è¡Œã€‚

é€šè¿‡wait_forè¿”å›çŠ¶æ€æ¥åˆ¤æ–­ï¼š

```
std::future_status status = result.wait_for(0s);
if(status == std::future_status::deferred){
	// çº¿ç¨‹è¢«å»¶è¿Ÿæ‰§è¡Œäº†ï¼ˆç³»ç»Ÿèµ„æºç´§å¼ ï¼Œå®ƒç”¨äº†é‡‡ç”¨std::launch::deferredç­–ç•¥äº†ï¼‰
	std::cout<<result.get()<<endl;//è¿™ä¸ªæ—¶å€™æ‰å»è°ƒç”¨äº†mythread();
}
else if (status == std::future_status::ready){
    // ä»»åŠ¡æ²¡æœ‰è¢«æ¨è¿Ÿï¼Œå·²ç»å¼€å§‹è¿è¡Œäº†ï¼Œçº¿ç¨‹è¢«åˆ›å»ºäº†
    // çº¿ç¨‹è¿”å›æˆåŠŸ
    cout<< "çº¿ç¨‹æˆåŠŸæ‰§è¡Œå®Œæ¯•è¿”å›"<<endl;
    cout<< result.get() <<endl;
}
else{
		
	...
}

----------------------------------------------------------

std::future_status status = result.wait_for(std::chrono::seconds(6));
//std::future_status status = result.wait_for(6s);
	if (status == std::future_status::timeout) {
		//è¶…æ—¶ï¼šè¡¨ç¤ºçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œ
		cout << "è¶…æ—¶äº†ï¼Œçº¿ç¨‹è¿˜æ²¡æœ‰æ‰§è¡Œå®Œ" << endl;
	}
	else if (status == std::future_status::ready) {
		//è¡¨ç¤ºçº¿ç¨‹æˆåŠŸæ”¾å›
		cout << "çº¿ç¨‹æ‰§è¡ŒæˆåŠŸï¼Œè¿”å›" << endl;
		cout << result.get() << endl;
	}
	else if (status == std::future_status::deferred) {
		cout << "çº¿ç¨‹å»¶è¿Ÿæ‰§è¡Œ" << endl;
		cout << result.get() << endl;
	}

```



## 12. windowsä¸´ç•ŒåŒºã€å…¶ä»–å„ç§mutexäº’æ–¥é‡

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/b.png)

### ä¸€å’ŒäºŒã€windowsä¸´ç•ŒåŒº

Windowsä¸´ç•ŒåŒºï¼ŒåŒä¸€ä¸ªçº¿ç¨‹æ˜¯å¯ä»¥é‡å¤è¿›å…¥çš„ï¼Œä½†æ˜¯è¿›å…¥çš„æ¬¡æ•°ä¸ç¦»å¼€çš„æ¬¡æ•°å¿…é¡»ç›¸ç­‰ã€‚
C++äº’æ–¥é‡åˆ™ä¸å…è®¸åŒä¸€ä¸ªçº¿ç¨‹é‡å¤åŠ é”ã€‚

windowsä¸´ç•ŒåŒºæ˜¯åœ¨windowsç¼–ç¨‹ä¸­çš„å†…å®¹ï¼Œäº†è§£ä¸€ä¸‹å³å¯ï¼Œæ•ˆæœå‡ ä¹å¯ä»¥ç­‰åŒäºc++11çš„mutex
åŒ…å«#include <windows.h>
windowsä¸­çš„ä¸´ç•ŒåŒºåŒmutexä¸€æ ·ï¼Œå¯ä»¥ä¿æŠ¤ä¸€ä¸ªä»£ç æ®µã€‚ä½†windowsçš„ä¸´ç•ŒåŒºå¯ä»¥è¿›å…¥å¤šæ¬¡ï¼Œç¦»å¼€å¤šæ¬¡ï¼Œä½†æ˜¯è¿›å…¥çš„æ¬¡æ•°ä¸ç¦»å¼€çš„æ¬¡æ•°å¿…é¡»ç›¸ç­‰ï¼Œä¸ä¼šå¼•èµ·ç¨‹åºæŠ¥å¼‚å¸¸å‡ºé”™ã€‚

```
#include <iostream>
#include <thread>
#include <list>
#include <mutex>
#include <Windows.h>

#define __WINDOWSJQ_

using namespace std;

class A
{
public:
	// æŠŠæ”¶åˆ°çš„æ¶ˆæ¯ä¼ å…¥é˜Ÿåˆ—
	void inMsgRecvQueue()
	{
		for (size_t i = 0; i < 1000; ++i)
		{
			cout << "æ”¶åˆ°æ¶ˆæ¯ï¼Œå¹¶æ”¾å…¥é˜Ÿåˆ— " << i << endl;

#ifdef  __WINDOWSJQ_
			EnterCriticalSection(&my_winsec);	//	è¿›å…¥ä¸´ç•ŒåŒº
			//EnterCriticalSection(&my_winsec);	//	å¯ä»¥å†æ¬¡è¿›å…¥ä¸´ç•ŒåŒº,ç¨‹åºä¸ä¼šå‡ºé”™
			msgRecvQueue.push_back(i);
			LeaveCriticalSection(&my_winsec);	//	ç¦»å¼€ä¸´ç•ŒåŒº
			//LeaveCriticalSection(&my_winsec);	//	å¦‚æœè¿›å…¥ä¸¤æ¬¡ï¼Œå¿…é¡»ç¦»å¼€ä¸¤æ¬¡ä¸ä¼šæŠ¥é”™
#elif
			my_mutex.lock();
			msgRecvQueue.push_back(i);
			my_mutex.unlock();
#endif //  __WINDOWSJQ_
		}

		cout << "æ¶ˆæ¯å…¥é˜Ÿç»“æŸ" << endl;
	}

	// ä»é˜Ÿåˆ—ä¸­å–å‡ºæ¶ˆæ¯
	void outMsgRecvQueue()
	{
		for (size_t i = 0; i < 1000; ++i)
		{
#ifdef  __WINDOWSJQ_
			EnterCriticalSection(&my_winsec);	//	è¿›å…¥ä¸´ç•ŒåŒº
			if (!msgRecvQueue.empty())
			{
				// é˜Ÿåˆ—ä¸ä¸ºç©º
				int num = msgRecvQueue.front();
				cout << "ä»æ¶ˆæ¯é˜Ÿåˆ—ä¸­å–å‡º " << num << endl;
				msgRecvQueue.pop_front();
			}
			else
			{
				// æ¶ˆæ¯é˜Ÿåˆ—ä¸ºç©º
				cout << "æ¶ˆæ¯é˜Ÿåˆ—ä¸ºç©º " << endl;
			}
			LeaveCriticalSection(&my_winsec);	//	ç¦»å¼€ä¸´ç•ŒåŒº
#elif
			my_mutex.lock();
			if (!msgRecvQueue.empty())
			{
				// é˜Ÿåˆ—ä¸ä¸ºç©º
				int num = msgRecvQueue.front();
				cout << "ä»æ¶ˆæ¯é˜Ÿåˆ—ä¸­å–å‡º " << num << endl;
				msgRecvQueue.pop_front();
				my_mutex.unlock();
			}
			else
			{
				// æ¶ˆæ¯é˜Ÿåˆ—ä¸ºç©º
				cout << "æ¶ˆæ¯é˜Ÿåˆ—ä¸ºç©º " << endl;
				my_mutex.unlock();
			}
#endif //  __WINDOWSJQ_
		}

		cout << "æ¶ˆæ¯å‡ºé˜Ÿç»“æŸ" << endl;
	}

	A()
	{
#ifdef __WINDOWSJQ_
		InitializeCriticalSection(&my_winsec);	//	ç”¨ä¸´ç•ŒåŒºä¹‹å‰è¦åˆå§‹åŒ–
#endif // __WINDOWSJQ_

	}

private:
	list<int> msgRecvQueue;
	mutex my_mutex;

#ifdef __WINDOWSJQ_
	CRITICAL_SECTION my_winsec;	//	windowsä¸­çš„ä¸´ç•ŒåŒºï¼Œéå¸¸ç±»ä¼¼C++11ä¸­çš„mutex
#endif // __WINDOWSJQ_

};

int main()
{
	A myobj;
	thread	myInMsgObj(&A::inMsgRecvQueue, &myobj);
	thread	myOutMsgObj(&A::outMsgRecvQueue, &myobj);
	myInMsgObj.join();
	myOutMsgObj.join();

	getchar();
	return 0;
}

```

### **ä¸‰ã€è‡ªåŠ¨ææ„æŠ€æœ¯**

C++ï¼šlock_guardé˜²æ­¢å¿˜äº†é‡Šæ”¾ä¿¡å·é‡ï¼Œè‡ªåŠ¨é‡Šæ”¾
windowsï¼šå¯ä»¥å†™ä¸ªç±»è‡ªåŠ¨é‡Šæ”¾ä¸´ç•ŒåŒºï¼š

```
class CWinLock {
public:
    CWinLock(CRITICAL_SECTION *pCritmp)
    {
        my_winsec =pCritmp;
        EnterCriticalSection(my_winsec);
    }
    ~CWinLock()
    {
        LeaveCriticalSection(my_winsec)
    };
private:
    CRITICAL_SECTION *my_winsec;
};

```

ä¸Šè¿°è¿™ç§ç±»RAIIç±»ï¼ˆResource Acquisition is initializationï¼‰ï¼Œå³èµ„æºè·å–åŠåˆå§‹åŒ–ã€‚å®¹å™¨ï¼Œæ™ºèƒ½æŒ‡é’ˆå±äºè¿™ç§ç±»ã€‚

### å››ã€é€’å½’ç‹¬å äº’æ–¥é‡ std::recursive_mutex

std::mutex ç‹¬å å¼äº’æ–¥é‡

std::recursive_mutexï¼šå…è®¸åœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸­åŒä¸€ä¸ªäº’æ–¥é‡å¤šæ¬¡è¢« lock() ï¼Œï¼ˆä½†æ˜¯é€’å½’åŠ é”çš„æ¬¡æ•°æ˜¯æœ‰é™åˆ¶çš„ï¼Œå¤ªå¤šå¯èƒ½ä¼šæŠ¥å¼‚å¸¸ï¼‰ï¼Œæ•ˆç‡è¦æ¯”mutexä½ã€‚

å¦‚æœä½ çœŸçš„ç”¨äº† recursive_mutex è¦è€ƒè™‘ä»£ç æ˜¯å¦æœ‰ä¼˜åŒ–ç©ºé—´ï¼Œå¦‚æœèƒ½è°ƒç”¨ä¸€æ¬¡ lock()å°±ä¸è¦è°ƒç”¨å¤šæ¬¡ã€‚

### äº”ã€å¸¦è¶…æ—¶çš„äº’æ–¥é‡ std::timed_mutex å’Œ std::recursive_timed_mutex

#### 5.1 std::timed_mutexï¼šæ˜¯å¾…è¶…æ—¶çš„ç‹¬å äº’æ–¥é‡

- try_lock_for()ï¼š

ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œå¦‚æœæ‹¿åˆ°äº†é”ï¼Œæˆ–è€…è¶…æ—¶äº†æœªæ‹¿åˆ°é”ï¼Œå°±ç»§ç»­æ‰§è¡Œï¼ˆæœ‰é€‰æ‹©æ‰§è¡Œï¼‰å¦‚ä¸‹ï¼š

```
std::chrono::milliseconds timeout(100);
if (my_mymutex.try_lock_for(timeout)){
    //......æ‹¿åˆ°é”è¿”å›ture
}
else{
    std::chrono::milliseconds sleeptime(100);
    std::this_thread::sleep_for(sleeptime);
}

```

- try_lock_until()ï¼š

å‚æ•°æ˜¯ä¸€ä¸ªæœªæ¥çš„æ—¶é—´ç‚¹ï¼Œåœ¨è¿™ä¸ªæœªæ¥çš„æ—¶é—´æ²¡åˆ°çš„æ—¶é—´å†…ï¼Œå¦‚æœæ‹¿åˆ°äº†é”å¤´ï¼Œæµç¨‹å°±èµ°ä¸‹æ¥ï¼Œå¦‚æœæ—¶é—´åˆ°äº†æ²¡æ‹¿åˆ°é”ï¼Œæµç¨‹ä¹Ÿå¯ä»¥èµ°ä¸‹æ¥ã€‚

```
std::chrono::milliseconds timeout(100);
if (my_mymutex.try_lock_until(chrono::steady_clock::now() + timeout)){
    //......æ‹¿åˆ°é”è¿”å›ture
}
else{
    std::chrono::milliseconds sleeptime(100);
    std::this_thread::sleep_for(sleeptime);
}

```

ä¸¤è€…çš„åŒºåˆ«å°±æ˜¯ä¸€ä¸ªå‚æ•°æ˜¯æ—¶é—´æ®µï¼Œä¸€ä¸ªå‚æ•°æ˜¯æ—¶é—´ç‚¹

#### *5.2 std::recursive_timed_mutexï¼šæ˜¯å¾…è¶…æ—¶çš„é€’å½’ç‹¬å äº’æ–¥é‡*

## 13. è¡¥å……çŸ¥è¯†ã€çº¿ç¨‹æ± æµ…è°ˆã€æ•°é‡è°ˆã€æ€»ç»“

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](imgs/a.png)

### ä¸€ã€è¡¥å……ä¸€äº›çŸ¥è¯†ç‚¹

#### 1.1 è™šå‡å”¤é†’ï¼š

notify_oneæˆ–è€…notify_allå”¤é†’wait()åï¼Œå®é™…æœ‰äº›çº¿ç¨‹å¯èƒ½ä¸æ»¡è¶³å”¤é†’çš„æ¡ä»¶ï¼Œå°±ä¼šé€ æˆè™šå‡å”¤é†’ï¼Œå¯ä»¥åœ¨waitä¸­å†æ¬¡è¿›è¡Œåˆ¤æ–­è§£å†³è™šå‡å”¤é†’ã€‚
è§£å†³ï¼šwaitä¸­è¦æœ‰ç¬¬äºŒä¸ªå‚æ•°ï¼ˆlambdaï¼‰ï¼Œå¹¶ä¸”è¿™ä¸ªlambdaä¸­è¦æ­£ç¡®åˆ¤æ–­æ‰€å¤„ç†çš„å…¬å…±æ•°æ®æ˜¯å¦å­˜åœ¨ã€‚

#### 2.2 atomicï¼š

```
std::atomic<int> atm = 0;
 
cout << atm << endl;

```

è¿™é‡Œåªæœ‰è¯»å–atmæ˜¯åŸå­æ“ä½œï¼Œä½†æ˜¯æ•´ä¸ªè¿™ä¸€è¡Œä»£ç  cout << atm << endl; å¹¶ä¸æ˜¯åŸå­æ“ä½œï¼Œå¯¼è‡´æœ€ç»ˆæ˜¾ç¤ºåœ¨å±å¹•ä¸Šçš„å€¼æ˜¯ä¸€ä¸ªâ€œæ›¾ç»å€¼â€ã€‚

```
std::atomic<int> atm = 0;
 
auto atm2 = atm; //ä¸å¯ä»¥

```

è¿™ç§æ‹·è´åˆå§‹åŒ–ä¸å¯ä»¥ï¼Œä¼šæŠ¥é”™ã€‚

```
atomic<int> atm2(atm.load());

```

load()ï¼šä»¥åŸå­æ–¹å¼è¯»atomicå¯¹è±¡çš„å€¼ã€‚

```
atm2.store(12);

```

åŸå­æ“ä½œå®è´¨ä¸Šæ˜¯ï¼šä¸å…è®¸åœ¨è¿›è¡ŒåŸå­å¯¹è±¡æ“ä½œæ—¶è¿›è¡ŒCPUçš„ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

### äºŒã€æµ…è°ˆçº¿ç¨‹æ± ï¼š

åœºæ™¯è®¾æƒ³ï¼šæœåŠ¡å™¨ç¨‹åºï¼Œ æ¯æ¥ä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ä¸ºè¿™ä¸ªå®¢æˆ·æä¾›æœåŠ¡ã€‚

é—®é¢˜ï¼š

1ã€2ä¸‡ä¸ªç©å®¶ï¼Œä¸å¯èƒ½ç»™æ¯ä¸ªç©å®¶åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œæ­¤ç¨‹åºå†™æ³•åœ¨è¿™ç§åœºæ™¯ä¸‹ä¸é€šã€‚

2ã€ç¨‹åºç¨³å®šæ€§é—®é¢˜ï¼šç¼–å†™ä»£ç ä¸­ï¼Œâ€œæ—¶ä¸æ—¶åœ°çªç„¶â€åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œè¿™ç§å†™æ³•ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸ä¼šå‡ºé”™ï¼Œä½†æ˜¯ä¸ç¨³å®šçš„ï¼›

çº¿ç¨‹æ± ï¼šæŠŠä¸€å †çº¿ç¨‹å¼„åˆ°ä¸€èµ·ï¼Œç»Ÿä¸€ç®¡ç†ã€‚è¿™ç§ç»Ÿä¸€ç®¡ç†è°ƒåº¦ï¼Œå¾ªç¯åˆ©ç”¨çš„æ–¹å¼ï¼Œå°±å«åšçº¿ç¨‹æ± ã€‚

å®ç°æ–¹å¼ï¼šç¨‹åºå¯åŠ¨æ—¶ï¼Œä¸€æ¬¡æ€§åˆ›å»ºå¥½ä¸€å®šæ•°é‡çš„çº¿ç¨‹ã€‚è¿™ç§æ–¹å¼è®©äººæ›´æ”¾å¿ƒï¼Œè§‰å¾—ç¨‹åºä»£ç æ›´ç¨³å®šã€‚

### ä¸‰ã€çº¿ç¨‹åˆ›å»ºæ•°é‡è°ˆï¼š

1ã€çº¿ç¨‹åˆ›å»ºçš„æ•°é‡æé™çš„é—®é¢˜

ä¸€èˆ¬æ¥è®²ï¼Œ2000ä¸ªçº¿ç¨‹åŸºæœ¬å°±æ˜¯æé™ï¼›å†åˆ›å»ºå°±ä¼šå´©æºƒã€‚

2ã€çº¿ç¨‹åˆ›å»ºæ•°é‡å»ºè®®

aã€é‡‡ç”¨æŸäº›è®¡æ•°å¼€å‘ç¨‹åºæä¾›çš„å»ºè®®ï¼Œéµç…§å»ºè®®å’ŒæŒ‡ç¤ºæ¥ç¡®ä¿ç¨‹åºé«˜æ•ˆæ‰§è¡Œã€‚

bã€åˆ›å»ºå¤šçº¿ç¨‹å®Œæˆä¸šåŠ¡ï¼›è€ƒè™‘å¯èƒ½è¢«é˜»å¡çš„çº¿ç¨‹æ•°é‡ï¼Œåˆ›å»ºå¤šä½™æœ€å¤§è¢«é˜»å¡çº¿ç¨‹æ•°é‡çš„çº¿ç¨‹ï¼Œå¦‚100ä¸ªçº¿ç¨‹è¢«é˜»å¡å†å……å€¼ä¸šåŠ¡ï¼Œå¼€110ä¸ªçº¿ç¨‹å°±æ˜¯å¾ˆåˆé€‚çš„

cã€çº¿ç¨‹åˆ›å»ºæ•°é‡å°½é‡ä¸è¦è¶…è¿‡500ä¸ªï¼Œå°½é‡æ§åˆ¶åœ¨200ä¸ªä¹‹å†…ï¼›


### å››ã€C++11å¤šçº¿ç¨‹æ€»ç»“

